<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Contiki-Inga 3.x: platform/sensinode/dev/m25p16.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-Inga 3.x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c5a52a81292cf9a5167198f4f346d6d9.html">platform</a></li><li class="navelem"><a class="el" href="dir_3be6dc26df19407c57120e0642748331.html">sensinode</a></li><li class="navelem"><a class="el" href="dir_2070b9750dfdae0899656befcc6aac88.html">dev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">m25p16.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><pre class="fragment">    Header file for the control of the M25P16 on sensinode N740s.</pre>  
<a href="#details">More...</a></p>

<p><a href="a01569_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">m25p16_rdid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device Identifier.  <a href="a00062.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2646b2d1fa254bbbc20fd72169bcbeed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a2646b2d1fa254bbbc20fd72169bcbeed">M25P16_BP</a>()&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_BP)</td></tr>
<tr class="memdesc:a2646b2d1fa254bbbc20fd72169bcbeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve Block Protect Bits from the status register.  <a href="#a2646b2d1fa254bbbc20fd72169bcbeed">More...</a><br/></td></tr>
<tr class="separator:a2646b2d1fa254bbbc20fd72169bcbeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af926e36d0c91beb2651e2eca14034b5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#af926e36d0c91beb2651e2eca14034b5c">M25P16_WIP</a>()&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_WIP)</td></tr>
<tr class="memdesc:af926e36d0c91beb2651e2eca14034b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for Write in Progress.  <a href="#af926e36d0c91beb2651e2eca14034b5c">More...</a><br/></td></tr>
<tr class="separator:af926e36d0c91beb2651e2eca14034b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5291b1731e901b56b85de7b683c7d877"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a5291b1731e901b56b85de7b683c7d877">M25P16_WEL</a>()&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_WEL)</td></tr>
<tr class="memdesc:a5291b1731e901b56b85de7b683c7d877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for Write-Enable.  <a href="#a5291b1731e901b56b85de7b683c7d877">More...</a><br/></td></tr>
<tr class="separator:a5291b1731e901b56b85de7b683c7d877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39bed720ac92d59a37ad9a2fc8ced923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a39bed720ac92d59a37ad9a2fc8ced923">m25p16_wren</a> ()</td></tr>
<tr class="memdesc:a39bed720ac92d59a37ad9a2fc8ced923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Enable (WREN) instruction.  <a href="#a39bed720ac92d59a37ad9a2fc8ced923">More...</a><br/></td></tr>
<tr class="separator:a39bed720ac92d59a37ad9a2fc8ced923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc99d85c5850f114a3d39368d2cb7c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc99d85c5850f114a3d39368d2cb7c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a1fc99d85c5850f114a3d39368d2cb7c3">m25p16_wrdi</a> ()</td></tr>
<tr class="memdesc:a1fc99d85c5850f114a3d39368d2cb7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Disable (WRDI) instruction. <br/></td></tr>
<tr class="separator:a1fc99d85c5850f114a3d39368d2cb7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229511f6d7b36488e29883b904125670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a229511f6d7b36488e29883b904125670">m25p16_rdid</a> (struct <a class="el" href="a00062.html">m25p16_rdid</a> *rdid)</td></tr>
<tr class="memdesc:a229511f6d7b36488e29883b904125670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Identifier (RDID)instruction.  <a href="#a229511f6d7b36488e29883b904125670">More...</a><br/></td></tr>
<tr class="separator:a229511f6d7b36488e29883b904125670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ffc91878cb343e1f151a0f38778eb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a> ()</td></tr>
<tr class="memdesc:aca2ffc91878cb343e1f151a0f38778eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Status Register (RDSR) instruction.  <a href="#aca2ffc91878cb343e1f151a0f38778eb">More...</a><br/></td></tr>
<tr class="separator:aca2ffc91878cb343e1f151a0f38778eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d08feb122ca405e2130cc1a3c75c643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a7d08feb122ca405e2130cc1a3c75c643">m25p16_wrsr</a> (uint8_t val)</td></tr>
<tr class="memdesc:a7d08feb122ca405e2130cc1a3c75c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Status Register (WRSR) instruction.  <a href="#a7d08feb122ca405e2130cc1a3c75c643">More...</a><br/></td></tr>
<tr class="separator:a7d08feb122ca405e2130cc1a3c75c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ab02660ecbb25862366e5421a9771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a696ab02660ecbb25862366e5421a9771">m25p16_read</a> (uint8_t *addr, uint8_t *buff, uint8_t buff_len)</td></tr>
<tr class="memdesc:a696ab02660ecbb25862366e5421a9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Data Bytes (READ) instruction.  <a href="#a696ab02660ecbb25862366e5421a9771">More...</a><br/></td></tr>
<tr class="separator:a696ab02660ecbb25862366e5421a9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e8e8161d16e1579f926421c96e760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a405e8e8161d16e1579f926421c96e760">m25p16_pp</a> (uint8_t *addr, uint8_t *buff, uint8_t buff_len)</td></tr>
<tr class="memdesc:a405e8e8161d16e1579f926421c96e760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program Page (PP) instruction.  <a href="#a405e8e8161d16e1579f926421c96e760">More...</a><br/></td></tr>
<tr class="separator:a405e8e8161d16e1579f926421c96e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420d47d32f08857620f020af7a85b6f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a420d47d32f08857620f020af7a85b6f1">m25p16_se</a> (uint8_t s)</td></tr>
<tr class="memdesc:a420d47d32f08857620f020af7a85b6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector Erase (SE) instruction.  <a href="#a420d47d32f08857620f020af7a85b6f1">More...</a><br/></td></tr>
<tr class="separator:a420d47d32f08857620f020af7a85b6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5feabad55c0b533d368773de2869d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#a6a5feabad55c0b533d368773de2869d7">m25p16_be</a> ()</td></tr>
<tr class="memdesc:a6a5feabad55c0b533d368773de2869d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Erase (SE) instruction.  <a href="#a6a5feabad55c0b533d368773de2869d7">More...</a><br/></td></tr>
<tr class="separator:a6a5feabad55c0b533d368773de2869d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cbc51dabc5aa595f9d0acf675a711a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#ac8cbc51dabc5aa595f9d0acf675a711a">m25p16_dp</a> ()</td></tr>
<tr class="memdesc:ac8cbc51dabc5aa595f9d0acf675a711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep Power Down (DP) instruction.  <a href="#ac8cbc51dabc5aa595f9d0acf675a711a">More...</a><br/></td></tr>
<tr class="separator:ac8cbc51dabc5aa595f9d0acf675a711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af894e635b54a8626d9a129c8c87dcbfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#af894e635b54a8626d9a129c8c87dcbfb">m25p16_res</a> ()</td></tr>
<tr class="memdesc:af894e635b54a8626d9a129c8c87dcbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release from Deep Power Down (RES) instruction.  <a href="#af894e635b54a8626d9a129c8c87dcbfb">More...</a><br/></td></tr>
<tr class="separator:af894e635b54a8626d9a129c8c87dcbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada69119d877cfabd3105953578163eb3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html#ada69119d877cfabd3105953578163eb3">m25p16_res_res</a> ()</td></tr>
<tr class="memdesc:ada69119d877cfabd3105953578163eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release from Deep Power Down (RES) and Read Electronic Signature instruction.  <a href="#ada69119d877cfabd3105953578163eb3">More...</a><br/></td></tr>
<tr class="separator:ada69119d877cfabd3105953578163eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">    Header file for the control of the M25P16 on sensinode N740s.</pre> <dl class="section author"><dt>Author</dt><dd>George Oikonomou - <a href="#" onclick="location.href='mai'+'lto:'+'oik'+'on'+'omo'+'u@'+'use'+'rs'+'.so'+'ur'+'cef'+'or'+'ge.'+'ne'+'t'; return false;">oikon<span style="display: none;">.nosp@m.</span>omou<span style="display: none;">.nosp@m.</span>@user<span style="display: none;">.nosp@m.</span>s.so<span style="display: none;">.nosp@m.</span>urcef<span style="display: none;">.nosp@m.</span>orge<span style="display: none;">.nosp@m.</span>.net</a> </dd></dl>

<p>Definition in file <a class="el" href="a01569_source.html">m25p16.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2646b2d1fa254bbbc20fd72169bcbeed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M25P16_BP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_BP)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve Block Protect Bits from the status register. </p>
<p>This macro returns the software block protect status on the device by reading the value of the BP bits ([5:3]) in the Status Register </p>

<p>Definition at line <a class="el" href="a01569_source.html#l00107">107</a> of file <a class="el" href="a01569_source.html">m25p16.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5291b1731e901b56b85de7b683c7d877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M25P16_WEL</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_WEL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for Write-Enable. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>Write enabled </td></tr>
    <tr><td class="paramname">0</td><td>Write disabled</td></tr>
  </table>
  </dd>
</dl>
<p>This macro checks if the device is ready to accept a write instruction by reading the value of the WEL bit (bit 1) in the Status Register </p>

<p>Definition at line <a class="el" href="a01569_source.html#l00125">125</a> of file <a class="el" href="a01569_source.html">m25p16.h</a>.</p>

<p>Referenced by <a class="el" href="a01568_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="af926e36d0c91beb2651e2eca14034b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M25P16_WIP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="a01569.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a>() &amp; M25P16_SR_WIP)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for Write in Progress. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>Write in progress </td></tr>
    <tr><td class="paramname">0</td><td>Write not in progress</td></tr>
  </table>
  </dd>
</dl>
<p>This macro checks if the device is currently in the middle of a write cycle by reading the value of the WIP bit (bit 0) in the Status Register </p>

<p>Definition at line <a class="el" href="a01569_source.html#l00116">116</a> of file <a class="el" href="a01569_source.html">m25p16.h</a>.</p>

<p>Referenced by <a class="el" href="a01568_source.html#l00284">m25p16_res()</a>, and <a class="el" href="a01568_source.html#l00300">m25p16_res_res()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6a5feabad55c0b533d368773de2869d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_be </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk Erase (SE) instruction. </p>
<p>Delete the entire memory, by setting it's contents to all 0xFF (which will read as 0x00 by READ).</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions.</p>
<p>This instructions takes a very long time to complete and must be used with care. It can take up to 40 secs (yes, secs). A typical duration is 13 secs </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00263">263</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01568_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8cbc51dabc5aa595f9d0acf675a711a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_dp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep Power Down (DP) instruction. </p>
<p>Puts the device into its lowers power consumption mode (This is not the same as the stand-by mode caused by de-selecting the device). While the device is in DP, it will accept no instruction except a RES (Release from DP).</p>
<p>This call is asynchronous and will return as soon as the instruction sequence has been written but before the device has actually entered DP</p>
<p>Dropping to DP takes 3usec and Resuming from DP takes at least 1.8usec, so this sequence should not be used when the sleep interval is estimated to be short (read as: don't DP then RES then DP repeatedly) </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00273">273</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="a405e8e8161d16e1579f926421c96e760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_pp </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buff_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program Page (PP) instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>3 byte array holding the write start address. MSB stored in addr[0] and LSB in addr[2] </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to a buffer with the data to be written </td></tr>
    <tr><td class="paramname">buff_len</td><td>Number of bytes to write, Maximum 256 bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>Write BUFF_LEN bytes stored in BUFF to flash, starting from location ADDR. BUFF_LEN may not exceed 256. ADDR should point to a 3 byte array, with the address MSB stored in position 0 and LSB in position 2</p>
<p>If the start address + buff_len exceed page boundaries, the write will wrap to the start of the same page (the page at addr[2:1]).</p>
<p>The bytes will be inverted before being written, so that a value of 0xFF will be written as 0x00 (and subsequently correctly read as 0xFF by READ)</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions. This can take up to 5 msecs (typical duration for a 256 byte write is 640 usec) </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00224">224</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01568_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="a229511f6d7b36488e29883b904125670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00062.html">m25p16_rdid</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00062.html">m25p16_rdid</a> *&#160;</td>
          <td class="paramname"><em>rdid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Identifier (RDID)instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rdid</td><td>Pointer to a struct which will hold the information returned by the RDID instruction </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01568_source.html#l00149">149</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01569_source.html#l00096">m25p16_rdid::mem_size</a>, <a class="el" href="a01569_source.html#l00095">m25p16_rdid::mem_type</a>, <a class="el" href="a01569_source.html#l00098">m25p16_rdid::uid</a>, and <a class="el" href="a01569_source.html#l00097">m25p16_rdid::uid_len</a>.</p>

</div>
</div>
<a class="anchor" id="aca2ffc91878cb343e1f151a0f38778eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t m25p16_rdsr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Status Register (RDSR) instruction. </p>
<dl class="section return"><dt>Returns</dt><dd>Value of the status register</dd></dl>
<p>Reads and returns the value of the status register on the Flash Chip </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00167">167</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="a696ab02660ecbb25862366e5421a9771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buff_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Data Bytes (READ) instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>3 byte array holding the read start address. MSB stored in addr[0] and LSB in addr[2] </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to a buffer to hold the read bytes. </td></tr>
    <tr><td class="paramname">buff_len</td><td>Number of bytes to read. buff must be long enough to hold buff_len bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The bytes will be inverted after being read, so that a value of 0xFF (empty) in the flash will read as 0x00 </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00193">193</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="af894e635b54a8626d9a129c8c87dcbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_res </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release from Deep Power Down (RES) instruction. </p>
<p>Take the device out of the Deep Power Down mode and bring it to standby. Does not read the electronic signature.</p>
<p>This call is synchronous. When it returns the device will be in standby mode.</p>
<p>Dropping to DP takes 3usec and Resuming from DP takes at least 1.8usec, so this sequence should not be used when the sleep interval is estimated to be short (read as: don't DP then RES then DP repeatedly) </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00284">284</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01569_source.html#l00116">M25P16_WIP</a>.</p>

</div>
</div>
<a class="anchor" id="ada69119d877cfabd3105953578163eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t m25p16_res_res </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release from Deep Power Down (RES) and Read Electronic Signature instruction. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the electronic signature. This is provided for backward compatibility and must always be 0x14</dd></dl>
<p>Take the device out of the Deep Power Down mode and bring it to standby. Does not read the electronic signature.</p>
<p>This call is synchronous. When it returns the device will be in standby mode.</p>
<p>Dropping to DP takes 3usec and Resuming from DP takes at least 1.8usec, so this sequence should not be used when the sleep interval is estimated to be short (read as: don't DP then RES then DP repeatedly)</p>
<p>Release from Deep Power Down (RES) and Read Electronic Signature instruction.</p>
<p>Read and return the Electronic Signature must return 0x14</p>
<dl class="section return"><dt>Returns</dt><dd>The old style Electronic Signature. This must be 0x14 </dd></dl>

<p>Definition at line <a class="el" href="a01568_source.html#l00300">300</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01569_source.html#l00116">M25P16_WIP</a>.</p>

</div>
</div>
<a class="anchor" id="a420d47d32f08857620f020af7a85b6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_se </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sector Erase (SE) instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The number of the sector to be erased</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the entire sector number s, by setting it's contents to all 0xFF (which will read as 0x00 by READ). The flash is broken down into 32 sectors, 64 KBytes each.</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions. This can take up to 3 secs (typical duration 600 msec) </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00248">248</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01568_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="a39bed720ac92d59a37ad9a2fc8ced923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_wren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Enable (WREN) instruction. </p>
<p>Completing a WRDI, PP, SE, BE and WRSR resets the write enable latch bit, so this instruction should be used every time before trying to write. </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00131">131</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01569_source.html#l00125">M25P16_WEL</a>.</p>

<p>Referenced by <a class="el" href="a01568_source.html#l00263">m25p16_be()</a>, <a class="el" href="a01568_source.html#l00224">m25p16_pp()</a>, <a class="el" href="a01568_source.html#l00248">m25p16_se()</a>, and <a class="el" href="a01568_source.html#l00180">m25p16_wrsr()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d08feb122ca405e2130cc1a3c75c643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void m25p16_wrsr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Status Register (WRSR) instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be written to the status register</td></tr>
  </table>
  </dd>
</dl>
<p>This instruction does not afect bits 6, 5, 1 and 0 of the SR. </p>

<p>Definition at line <a class="el" href="a01568_source.html#l00180">180</a> of file <a class="el" href="a01568_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01568_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 24 2014 16:26:18 for Contiki-Inga 3.x by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
