<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Contiki-Inga 3.x: The Contiki/uIP interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-Inga 3.x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">The Contiki/uIP interface<div class="ingroups"><a class="el" href="a01866.html">The uIP TCP/IP stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00272"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">tcpip.h</a></td></tr>
<tr class="memdesc:a00272"><td class="mdescLeft">&#160;</td><td class="mdescRight"><pre class="fragment">     Header for the Contiki/uIP interface.</pre> <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga41aa744caa46913b3b3aedb2a4e78546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41aa744caa46913b3b3aedb2a4e78546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga41aa744caa46913b3b3aedb2a4e78546">UIP_APPCALL</a>&#160;&#160;&#160;tcpip_uipcall</td></tr>
<tr class="memdesc:ga41aa744caa46913b3b3aedb2a4e78546"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the application function that uIP should call in response to TCP/IP events. <br/></td></tr>
<tr class="separator:ga41aa744caa46913b3b3aedb2a4e78546"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaadf3c3b5770cafe3da7f8cc4dd06625c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> process_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gaadf3c3b5770cafe3da7f8cc4dd06625c">tcpip_event</a></td></tr>
<tr class="memdesc:gaadf3c3b5770cafe3da7f8cc4dd06625c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP event.  <a href="#gaadf3c3b5770cafe3da7f8cc4dd06625c">More...</a><br/></td></tr>
<tr class="separator:gaadf3c3b5770cafe3da7f8cc4dd06625c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
TCP functions</h2></td></tr>
<tr class="memitem:ga8bc368a618bee21caad1c718ca5a1257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga8bc368a618bee21caad1c718ca5a1257">tcp_attach</a> (struct <a class="el" href="a00108.html">uip_conn</a> *conn, void *appstate)</td></tr>
<tr class="memdesc:ga8bc368a618bee21caad1c718ca5a1257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a TCP connection to the current process.  <a href="#ga8bc368a618bee21caad1c718ca5a1257">More...</a><br/></td></tr>
<tr class="separator:ga8bc368a618bee21caad1c718ca5a1257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6b81f8f3010563bf1a97205be39796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gafb6b81f8f3010563bf1a97205be39796">tcp_listen</a> (uint16_t port)</td></tr>
<tr class="memdesc:gafb6b81f8f3010563bf1a97205be39796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP port.  <a href="#gafb6b81f8f3010563bf1a97205be39796">More...</a><br/></td></tr>
<tr class="separator:gafb6b81f8f3010563bf1a97205be39796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96bc5b9d24baef6962e130b656e4db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gab96bc5b9d24baef6962e130b656e4db6">tcp_unlisten</a> (uint16_t port)</td></tr>
<tr class="memdesc:gab96bc5b9d24baef6962e130b656e4db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a listening TCP port.  <a href="#gab96bc5b9d24baef6962e130b656e4db6">More...</a><br/></td></tr>
<tr class="separator:gab96bc5b9d24baef6962e130b656e4db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f3e8973f0717e0f46d6a16a7fd5474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00108.html">uip_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga51f3e8973f0717e0f46d6a16a7fd5474">tcp_connect</a> (uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:ga51f3e8973f0717e0f46d6a16a7fd5474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP connection to the specified IP address and port.  <a href="#ga51f3e8973f0717e0f46d6a16a7fd5474">More...</a><br/></td></tr>
<tr class="separator:ga51f3e8973f0717e0f46d6a16a7fd5474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga7ba71f5f4d459854a5b1e09e6d77b252">tcpip_poll_tcp</a> (struct <a class="el" href="a00108.html">uip_conn</a> *conn)</td></tr>
<tr class="memdesc:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified TCP connection to be polled.  <a href="#ga7ba71f5f4d459854a5b1e09e6d77b252">More...</a><br/></td></tr>
<tr class="separator:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228f0c0f1c20d43a7fda39b3b8f0fd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga228f0c0f1c20d43a7fda39b3b8f0fd4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_markconn</b>(conn, appstate)&#160;&#160;&#160;<a class="el" href="a01721.html#ga8bc368a618bee21caad1c718ca5a1257">tcp_attach</a>(conn, appstate)</td></tr>
<tr class="separator:ga228f0c0f1c20d43a7fda39b3b8f0fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UDP functions</h2></td></tr>
<tr class="memitem:ga3cb4f212906fc7b8909a3f8938006470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga3cb4f212906fc7b8909a3f8938006470">udp_attach</a> (struct <a class="el" href="a00135.html">uip_udp_conn</a> *conn, void *appstate)</td></tr>
<tr class="memdesc:ga3cb4f212906fc7b8909a3f8938006470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the current process to a UDP connection.  <a href="#ga3cb4f212906fc7b8909a3f8938006470">More...</a><br/></td></tr>
<tr class="separator:ga3cb4f212906fc7b8909a3f8938006470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fda54f49c58d830df5faed1541e2a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00135.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga8fda54f49c58d830df5faed1541e2a62">udp_new</a> (const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:ga8fda54f49c58d830df5faed1541e2a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP connection.  <a href="#ga8fda54f49c58d830df5faed1541e2a62">More...</a><br/></td></tr>
<tr class="separator:ga8fda54f49c58d830df5faed1541e2a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0394436a6f855ec38871cacd01f8c9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="a00135.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gabd0394436a6f855ec38871cacd01f8c9">udp_broadcast_new</a> (uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:gabd0394436a6f855ec38871cacd01f8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP broadcast connection.  <a href="#gabd0394436a6f855ec38871cacd01f8c9">More...</a><br/></td></tr>
<tr class="separator:gabd0394436a6f855ec38871cacd01f8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f9cca40d8c2043f405ee372a6de0d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga98f9cca40d8c2043f405ee372a6de0d1">tcpip_poll_udp</a> (struct <a class="el" href="a00135.html">uip_udp_conn</a> *conn)</td></tr>
<tr class="memdesc:ga98f9cca40d8c2043f405ee372a6de0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified UDP connection to be polled.  <a href="#ga98f9cca40d8c2043f405ee372a6de0d1">More...</a><br/></td></tr>
<tr class="separator:ga98f9cca40d8c2043f405ee372a6de0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b8211f05d7e2ef4d521274d07191e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga22b8211f05d7e2ef4d521274d07191e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udp_markconn</b>(conn, appstate)&#160;&#160;&#160;<a class="el" href="a01721.html#ga3cb4f212906fc7b8909a3f8938006470">udp_attach</a>(conn, appstate)</td></tr>
<tr class="separator:ga22b8211f05d7e2ef4d521274d07191e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afb919d5d0923a55252eeb46caf58d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga6afb919d5d0923a55252eeb46caf58d6">udp_bind</a>(conn, port)&#160;&#160;&#160;<a class="el" href="a01726.html#gaa20812098a4663c8a9fc4ce8e95391b6">uip_udp_bind</a>(conn, port)</td></tr>
<tr class="memdesc:ga6afb919d5d0923a55252eeb46caf58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a UDP connection to a local port.  <a href="#ga6afb919d5d0923a55252eeb46caf58d6">More...</a><br/></td></tr>
<tr class="separator:ga6afb919d5d0923a55252eeb46caf58d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
TCP/IP packet processing</h2></td></tr>
<tr class="memitem:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf7bd597f63c175c2f5e90e10cc67c0c"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a></td></tr>
<tr class="memdesc:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is forwarding generally enabled? <br/></td></tr>
<tr class="separator:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3e06288277302a1fe329b3f68ca953"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f3e06288277302a1fe329b3f68ca953"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_is_forwarding</b></td></tr>
<tr class="separator:ga9f3e06288277302a1fe329b3f68ca953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5e21d13844dbebd703fb8ed6b058d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga0d5e21d13844dbebd703fb8ed6b058d0">tcpip_input</a> (void)</td></tr>
<tr class="memdesc:ga0d5e21d13844dbebd703fb8ed6b058d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deliver an incoming packet to the TCP/IP stack.  <a href="#ga0d5e21d13844dbebd703fb8ed6b058d0">More...</a><br/></td></tr>
<tr class="separator:ga0d5e21d13844dbebd703fb8ed6b058d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3457ae0795bde06732b071f8f182da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e3457ae0795bde06732b071f8f182da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#ga5e3457ae0795bde06732b071f8f182da">tcpip_output</a> (const <a class="el" href="a01866.html#ga239a73d412e4d6ce81473305919856cc">uip_lladdr_t</a> *)</td></tr>
<tr class="memdesc:ga5e3457ae0795bde06732b071f8f182da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output packet to layer 2 The eventual parameter is the MAC address of the destination. <br/></td></tr>
<tr class="separator:ga5e3457ae0795bde06732b071f8f182da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e52f870d1bee88d99b3f0e75eaf9116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e52f870d1bee88d99b3f0e75eaf9116"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_set_outputfunc</b> (uint8_t(*f)(const <a class="el" href="a01866.html#ga239a73d412e4d6ce81473305919856cc">uip_lladdr_t</a> *))</td></tr>
<tr class="separator:ga9e52f870d1bee88d99b3f0e75eaf9116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ae7c413a050ec6778b2f9c58dee361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3ae7c413a050ec6778b2f9c58dee361"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html#gad3ae7c413a050ec6778b2f9c58dee361">tcpip_ipv6_output</a> (void)</td></tr>
<tr class="memdesc:gad3ae7c413a050ec6778b2f9c58dee361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does address resolution and then calls tcpip_output. <br/></td></tr>
<tr class="separator:gad3ae7c413a050ec6778b2f9c58dee361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacccb4e63afa84573fbef8a071dbf8b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacccb4e63afa84573fbef8a071dbf8b5c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_set_forwarding</b>(forwarding)&#160;&#160;&#160;<a class="el" href="a01721.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a> = (forwarding)</td></tr>
<tr class="separator:gacccb4e63afa84573fbef8a071dbf8b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack. </p>
<p>For sending and receiving data, Contiki uses the functions provided by the uIP module, but Contiki adds a set of functions for connection management. The connection management functions make sure that the uIP TCP/IP connections are connected to the correct process.</p>
<p>Contiki also includes an optional protosocket library that provides an API similar to the BSD socket API.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01866.html">The uIP TCP/IP stack</a> </dd>
<dd>
<a class="el" href="a01717.html">Protosockets library</a> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6afb919d5d0923a55252eeb46caf58d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udp_bind</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">conn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="a01726.html#gaa20812098a4663c8a9fc4ce8e95391b6">uip_udp_bind</a>(conn, port)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a UDP connection to a local port. </p>
<p>This function binds a UDP connection to a specified local port.</p>
<p>When a connection is created with <a class="el" href="a01721.html#ga8fda54f49c58d830df5faed1541e2a62" title="Create a new UDP connection.">udp_new()</a>, it gets a local port number assigned automatically. If the application needs to bind the connection to a specified local port, this function should be used.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01727.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that is to be bound. </td></tr>
    <tr><td class="paramname">port</td><td>The port number in network byte order to which to bind the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00272_source.html#l00261">261</a> of file <a class="el" href="a00272_source.html">tcpip.h</a>.</p>

<p>Referenced by <a class="el" href="a00265_source.html#l00164">simple_udp_register()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8bc368a618bee21caad1c718ca5a1257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void tcp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00108.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a TCP connection to the current process. </p>
<p>This function attaches the current process to a TCP connection. Each TCP connection must be attached to a process in order for the process to be able to receive and send data. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51f3e8973f0717e0f46d6a16a7fd5474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00108.html">uip_conn</a>* tcp_connect </td>
          <td>(</td>
          <td class="paramtype">uip_ipaddr_t *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a TCP connection to the specified IP address and port. </p>
<p>This function opens a TCP connection to the specified port at the host specified with an IP address. Additionally, an opaque pointer can be attached to the connection. This pointer will be sent together with uIP events to the process.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01727.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd>
<dd>
This function will only create the connection. The connection is not opened directly. uIP will try to open the connection the next time the uIP stack is scheduled by Contiki.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb6b81f8f3010563bf1a97205be39796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void tcp_listen </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a TCP port. </p>
<p>This function opens a TCP port for listening. When a TCP connection request occurs for the port, the process will be sent a tcpip_event with the new connection request.</p>
<dl class="section note"><dt>Note</dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="a01727.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> and <a class="el" href="a01727.html#ga1079e0565aba46fc127b7ad6a4cf39b1" title="Convert a 16-bit quantity from host byte order to network byte order.">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00005.html#a12">example-psock-server.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab96bc5b9d24baef6962e130b656e4db6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void tcp_unlisten </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a listening TCP port. </p>
<p>This function closes a listening TCP port.</p>
<dl class="section note"><dt>Note</dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="a01727.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> and <a class="el" href="a01727.html#ga1079e0565aba46fc127b7ad6a4cf39b1" title="Convert a 16-bit quantity from host byte order to network byte order.">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d5e21d13844dbebd703fb8ed6b058d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void tcpip_input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deliver an incoming packet to the TCP/IP stack. </p>
<p>This function is called by network device drivers to deliver an incoming packet to the TCP/IP stack. The incoming packet must be present in the uip_buf buffer, and the length of the packet must be in the global uip_len variable. </p>

<p>Definition at line <a class="el" href="a00271_source.html#l00528">528</a> of file <a class="el" href="a00271_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="a01200_source.html#l00186">NULL</a>, <a class="el" href="a00473_source.html#l00362">process_post_synch()</a>, <a class="el" href="a00328_source.html#l00136">uip_ext_len</a>, and <a class="el" href="a00328_source.html#l00184">uip_len</a>.</p>

<p>Referenced by <a class="el" href="a01332_source.html#l00330">mac_ethernetToLowpan()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ba71f5f4d459854a5b1e09e6d77b252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_poll_tcp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00108.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a specified TCP connection to be polled. </p>
<p>This function causes uIP to poll the specified TCP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98f9cca40d8c2043f405ee372a6de0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void tcpip_poll_udp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00135.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a specified UDP connection to be polled. </p>
<p>This function causes uIP to poll the specified UDP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00002.html#a13">example-program.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3cb4f212906fc7b8909a3f8938006470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00135.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the current process to a UDP connection. </p>
<p>This function attaches the current process to a UDP connection. Each UDP connection must have a process attached to it in order for the process to be able to receive and send data over the connection. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd0394436a6f855ec38871cacd01f8c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00135.html">uip_udp_conn</a>* udp_broadcast_new </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new UDP broadcast connection. </p>
<p>This function creates a new (link-local) broadcast UDP connection to a specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00002.html#a6">example-program.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8fda54f49c58d830df5faed1541e2a62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00135.html">uip_udp_conn</a>* udp_new </td>
          <td>(</td>
          <td class="paramtype">const uip_ipaddr_t *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new UDP connection. </p>
<p>This function creates a new UDP connection with the specified remote endpoint.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="a01727.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order.">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01721.html#ga6afb919d5d0923a55252eeb46caf58d6" title="Bind a UDP connection to a local port.">udp_bind()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Referenced by <a class="el" href="a00265_source.html#l00164">simple_udp_register()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gaadf3c3b5770cafe3da7f8cc4dd06625c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> process_event_t tcpip_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The uIP event. </p>
<p>This event is posted to a process whenever a uIP event has occurred. </p>

<p>Definition at line <a class="el" href="a00271_source.html#l00074">74</a> of file <a class="el" href="a00271_source.html">tcpip.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 24 2014 16:26:18 for Contiki-Inga 3.x by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
