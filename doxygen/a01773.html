<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Contiki-Inga 3.x: Nvm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-Inga 3.x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Nvm<div class="ingroups"><a class="el" href="a01885.html">Stm32w-cpu</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cortex-M3 Non-Volatile Memory data storage system.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac69b416959214ba71992405f12df6194"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gac69b416959214ba71992405f12df6194">NVM_FLASH_PAGE_COUNT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gac69b416959214ba71992405f12df6194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the number of physical flash pages that comprise a NVM page.  <a href="#gac69b416959214ba71992405f12df6194">More...</a><br/></td></tr>
<tr class="separator:gac69b416959214ba71992405f12df6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82c3a8a7dccec38e893a2cf87cfcd72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gaf82c3a8a7dccec38e893a2cf87cfcd72">NVM_DATA_SIZE_B</a>&#160;&#160;&#160;(MFB_PAGE_SIZE_B*<a class="el" href="a01773.html#gac69b416959214ba71992405f12df6194">NVM_FLASH_PAGE_COUNT</a>)</td></tr>
<tr class="memdesc:gaf82c3a8a7dccec38e893a2cf87cfcd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the total size of a NVM page, in bytes.  <a href="#gaf82c3a8a7dccec38e893a2cf87cfcd72">More...</a><br/></td></tr>
<tr class="separator:gaf82c3a8a7dccec38e893a2cf87cfcd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce94dda9f5641155bbb4eae60a7ede6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#ga2ce94dda9f5641155bbb4eae60a7ede6">NVM_LEFT_PAGE</a>&#160;&#160;&#160;((uint32_t)nvmStorageLeft)</td></tr>
<tr class="memdesc:ga2ce94dda9f5641155bbb4eae60a7ede6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the absolute address of the LEFT page.  <a href="#ga2ce94dda9f5641155bbb4eae60a7ede6">More...</a><br/></td></tr>
<tr class="separator:ga2ce94dda9f5641155bbb4eae60a7ede6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d032a9b1418fc2378f7dd35df05738"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gac6d032a9b1418fc2378f7dd35df05738">NVM_RIGHT_PAGE</a>&#160;&#160;&#160;((uint32_t)nvmStorageRight)</td></tr>
<tr class="memdesc:gac6d032a9b1418fc2378f7dd35df05738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the absolute address of the RIGHT page.  <a href="#gac6d032a9b1418fc2378f7dd35df05738">More...</a><br/></td></tr>
<tr class="separator:gac6d032a9b1418fc2378f7dd35df05738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8953aab91c6b245cd9c0f03fe88d4bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gac8953aab91c6b245cd9c0f03fe88d4bf">NVM_MGMT_SIZE_B</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:gac8953aab91c6b245cd9c0f03fe88d4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the number of bytes that comprise the NVM management bytes.  <a href="#gac8953aab91c6b245cd9c0f03fe88d4bf">More...</a><br/></td></tr>
<tr class="separator:gac8953aab91c6b245cd9c0f03fe88d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2c0e291bd7439de367cf9ec7fc2e8b01"><td class="memItemLeft" align="right" valign="top">StStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#ga2c0e291bd7439de367cf9ec7fc2e8b01">halCommonReadFromNvm</a> (void *data, uint32_t offset, uint16_t length)</td></tr>
<tr class="memdesc:ga2c0e291bd7439de367cf9ec7fc2e8b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the NVM data from flash into the provided RAM location.  <a href="#ga2c0e291bd7439de367cf9ec7fc2e8b01">More...</a><br/></td></tr>
<tr class="separator:ga2c0e291bd7439de367cf9ec7fc2e8b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafd619bfdb67ff71b389c2fdbd59785"><td class="memItemLeft" align="right" valign="top">uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gafafd619bfdb67ff71b389c2fdbd59785">halCommonGetAddressFromNvm</a> (uint32_t offset)</td></tr>
<tr class="memdesc:gafafd619bfdb67ff71b389c2fdbd59785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of the token in NVM.  <a href="#gafafd619bfdb67ff71b389c2fdbd59785">More...</a><br/></td></tr>
<tr class="separator:gafafd619bfdb67ff71b389c2fdbd59785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa106c8d6e88a6224f232fe5824cca9f7"><td class="memItemLeft" align="right" valign="top">StStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html#gaa106c8d6e88a6224f232fe5824cca9f7">halCommonWriteToNvm</a> (const void *data, uint32_t offset, uint16_t length)</td></tr>
<tr class="memdesc:gaa106c8d6e88a6224f232fe5824cca9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the NVM data from the provided location RAM into flash.  <a href="#gaa106c8d6e88a6224f232fe5824cca9f7">More...</a><br/></td></tr>
<tr class="separator:gaa106c8d6e88a6224f232fe5824cca9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cortex-M3 Non-Volatile Memory data storage system. </p>
<p>Data definitions for the Cortex-M3 Non-Volatile Memory data storage system.</p>
<p>This header defines the API for NVM data storage. This header also describes the algorithm behind the NVM data storage system with notes on algorithm behavior.</p>
<p>See <a class="el" href="a01169.html" title="Cortex-M3 Non-Volatile Memory data storage system.">hal/micro/cortexm3/nvm.h</a> for source code.</p>
<dl class="section note"><dt>Note</dt><dd>The algorithm description uses "page" to indicate an area of memory that is a multiple of physical flash pages. There are two pages: LEFT and RIGHT. The term "flash page" is used to refer to a page of physical flash.</dd></dl>
<p>NVM data storage works by alternating between two pages: LEFT and RIGHT. The basic algorithm is driven by a call to halCommonSaveToNvm(). It will:</p>
<ul>
<li>erase the inactive page</li>
<li>write the new data to the inactive page</li>
<li>copy existing data from the active page to the inactive page</li>
<li>mark the inactive page as the new active page</li>
<li>mark the old active page as the new inactive page To accomplish alternating between two pages and knowing which page has the valid set of data, the algorithm uses 4 bytes of mgmt data that exists at the top of both LEFT and RIGHT (the term "mgmt" is shorthand referring to the management data). The management data is comprised of a Valid marker, an Active marker, a Dead marker, and a Spare byte. Viewing the management data as a single 32 bit quantity yields:</li>
<li>Valid is mgmt[0]</li>
<li>Active is mgmt[1]</li>
<li>Dead is mgmt[2]</li>
<li>Spare is mgmt[3] The algorithm is based on a simple, circular state machine. The following discussion details all of the possible mgmt bytes and the states they correspond to. The "Reads from" line indicates which page a call to <a class="el" href="a01773.html#ga2c0e291bd7439de367cf9ec7fc2e8b01" title="Copy the NVM data from flash into the provided RAM location.">halCommonReadFromNvm()</a> will read from (an 'x' page will stuff the read data with 0xFF). The vertical "erase" and "write" words indicate the flash altering actions taken between those states. Invalid mgmt bytes is equivalent to erased mgmt bytes (state 0) and will trigger an erase of both LEFT and RIGHT. State 3 and state 7 are the only exit states. When the algorithm is run, regardless of starting state, it will advance to the next exit state. This means if the "Read from" is LEFT then the state machine will advance until state 7 and then exit. If "Read from" is RIGHT, then the state machine will advance until state 3 and then exit.</li>
</ul>
<div class="fragment"><div class="line">Starting from erased or invalid mgmt, write to LEFT</div>
<div class="line">State #       0     0         1      2      3  </div>
<div class="line">Reads from:   x     x   e w   L      L      L  </div>
<div class="line">Valid       xx|xx FF|FF r r 00|FF  00|FF  00|00</div>
<div class="line">Active      xx|xx FF|FF a i 00|FF  00|FF  00|00</div>
<div class="line">Dead        xx|xx FF|FF s t FF|FF  FF|00  FF|00</div>
<div class="line">Spare       xx|xx FF|FF e e FF|FF  FF|FF  FF|FF</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Starting from LEFT page, transition to RIGHT page:</div>
<div class="line">State #      3       4       5      6      7  </div>
<div class="line">Reads from:  L   e   L   w   R      R      R  </div>
<div class="line">Valid      00|00 r 00|FF r 00|00  00|00  00|00</div>
<div class="line">Active     00|00 a 00|FF i 00|FF  00|FF  00|00</div>
<div class="line">Dead       FF|00 s FF|FF t FF|FF  00|FF  00|FF</div>
<div class="line">Spare      FF|FF e FF|FF e FF|FF  FF|FF  FF|FF</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Starting from RIGHT page, transition to LEFT page:</div>
<div class="line">State #      7       8       9     10      3  </div>
<div class="line">Reads from:  R   e   R   w   L      L      L  </div>
<div class="line">Valid      00|00 r FF|00 r 00|00  00|00  00|00</div>
<div class="line">Active     00|00 a FF|00 i FF|00  FF|00  00|00</div>
<div class="line">Dead       00|FF s FF|FF t FF|FF  FF|00  FF|00</div>
<div class="line">Spare      FF|FF e FF|FF e FF|FF  FF|FF  FF|FF</div>
</div><!-- fragment --><p>Based on the 10 possible states, there are 5 valid 32bit mgmt words:</p>
<ul>
<li>0xFFFFFFFF</li>
<li>0xFFFFFF00</li>
<li>0xFFFF0000</li>
<li>0xFF000000</li>
<li>0xFF00FFFF The algorithm determines the current state by using these 5 mgmt words with the 10 possible combinations of LEFT mgmt and RIGHT mgmt.</li>
</ul>
<p>Detailed State Description:</p>
<ul>
<li>State 0: In this state the mgmt bytes do not conform to any of the other states and therefore the entire NVM system, both the LEFT and RIGHT, is invalid. Invalid could be as simple as both LEFT and RIGHT are erased or as complex as serious memory corruption or a bug caused bad data to be written to the NVM. By using a small set of very strict, precise, valid states (versus other management systems such as a simple counter), the algorithm/data gains some protection against not only corruption, but also executing the NVM algorithm on a chip that previously did not have the NVM system running on it.</li>
<li>State 1, 4, 8 In these states, mgmt is saying that one page is valid and active, while the other page is erased. This tells the algorithm which page to read from and indicates that the other page has already been erased.</li>
<li>State 2 This state is only necessary for transitioning from state 0. From state 0, the goal is to arrive at state 3. Ideally, the RIGHT mgmt would be written with 0xFF000000, but the flash library only permits 16 bit writes. If a reset were to occur in the middle of this section of the algorithm, we want to ensure that the mgmt is left in a known state, state 2, so that the algorithm could continue from where it got interrupted.</li>
<li>State 5, 9 These states indicate that the other page has just become valid because the new data has just been written. Once at these states, reading from the NVM will now pull data from the other page.</li>
<li>State 6, 10 These states indicate that the old page is now dead and not in use. While the algorithm already knows to read from the new page, the Dead mgmt byte is primarily used to indicate that the other page needs to be erased. Conceptually, the Dead byte can also be considered a type of "garbage collection" flag indicating the old page needs to be destroyed and has not yet been erased.</li>
<li>State 3, 7 These states are the final exit points of the circular state machine. Once at these states, the current page is marked Valid and Active and the old page is marked as Dead. The algorithm knows which page to read from and which page needs to be erased on the next write to the NVM.</li>
</ul>
<p>Notes on algorithm behavior:</p>
<ul>
<li>Refer to <a class="el" href="a01166.html" title="Data definitions for the Cortex-M3 Non-Volatile Memory data storage system.">nvm-def.h</a> for a list of offset/length that define the data stored in NVM storage space.</li>
<li>All writes to flash are 16bit granularity and therefore the internal flash writes cast the data to uint16_t. Length is also required to be a multiple of 16bits.</li>
<li>Flash page erase uses a granularity of a single flash page. The size of a flash page depends on the chip and is defined in memmap.h with the define MFB_PAGE_SIZE_B.</li>
<li>Erasing will only occur when halCommonSaveToNvm() is called.</li>
<li>Erasing will always occur when halCommonSaveToNvm() is called unless the page intended to be erased is already entirely 0xFFFF.</li>
<li>When reading and management is invalid, the read will return 0xFF for data.</li>
<li>Calling halCommonSaveToNvm() while in any state is always valid and the new data will be written to flash.</li>
<li>halCommonSaveToNvm() will always advance the state machine to 3 or 7.</li>
<li>When writing and management is invalid, both LEFT and RIGHT will be erased and the new data will be written to LEFT.</li>
<li>Writing causes the new data being passed into halCommonSaveToNvm() to be written to flash. The data already existing in the currently valid page will be copied over to the new page.</li>
<li>Reading or writing to an offset equal to or greater than NVM_DATA_SIZE_B is illegal and will cause an assert.</li>
<li>Offset and length must always be multiples of 16bits. If not, both a read and a write will trigger an assert.</li>
<li>Offset and length must be supplied in bytes.</li>
<li>All data in NVM storage must exist above the mgmt bytes, denoted by NVM_MGMT_SIZE_B.</li>
<li>The bottom 64 bytes of NVM storage are allocated to radio calibration values. These 64 bytes <em>must</em> exist for the radio to function.</li>
<li>There is no error checking beyond checking for 16bit alignment. This means it is possible to use data offset and size combinations that exceed NVM storage space or overlap with other data. Be careful!</li>
</ul>
<p>This header defines all of the data sets in the NVM data storage. Each piece of data in NVM storage uses an offset to indicate where the data lives and a size to indicate the size of that data. Both the offset and size are defined in bytes and must be a mupltiple of 16bits. The offset is from the start of an NVM page, defined by NVM_LEFT_PAGE and NVM_RIGHT_PAGE. The offset and size must be below the maximum size of NVM storage as defined by NVM_DATA_SIZE_B. All NVM data must start above NVM_MGMT_SIZE_B, since this is where the management bytes live.</p>
<dl class="section note"><dt>Note</dt><dd>This file is not directly used by the nvm.c or nvm.h files. This file is intended to be a convenient place to define all data that lives in NVM so it can be seen together in one group. nvm.h includes this file which means any code that includes nvm.h to call the read and write functions also has access to these defines. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaf82c3a8a7dccec38e893a2cf87cfcd72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_DATA_SIZE_B&#160;&#160;&#160;(MFB_PAGE_SIZE_B*<a class="el" href="a01773.html#gac69b416959214ba71992405f12df6194">NVM_FLASH_PAGE_COUNT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the total size of a NVM page, in bytes. </p>
<p>This must be a multiple of the memory map define MFB_PAGE_SIZE_B. Note that 4 bytes of the total size of an NVM page are dedicated to page management.</p>
<dl class="section note"><dt>Note</dt><dd><b>DO NOT EDIT THIS DEFINE. Instead, edit NVM_FLASH_PAGE_COUNT.</b> </dd></dl>

<p>Definition at line <a class="el" href="a01169_source.html#l00253">253</a> of file <a class="el" href="a01169_source.html">nvm.h</a>.</p>

<p>Referenced by <a class="el" href="a01167_source.html#l00098">halCommonReadFromNvm()</a>, and <a class="el" href="a01167_source.html#l00280">halCommonWriteToNvm()</a>.</p>

</div>
</div>
<a class="anchor" id="gac69b416959214ba71992405f12df6194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_FLASH_PAGE_COUNT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the number of physical flash pages that comprise a NVM page. </p>
<p>Since NVM_DATA_SIZE_B must be a multiple of MFB_PAGE_SIZE_B, increasing the size of NVM storage should be done by modifying this define.</p>
<dl class="section note"><dt>Note</dt><dd>The total flash area consumed by NVM storage is double this value. This is due to the fact that there are two NVM pages, LEFT and RIGHT, which the algorithm alternates between. </dd></dl>

<p>Definition at line <a class="el" href="a01169_source.html#l00244">244</a> of file <a class="el" href="a01169_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ce94dda9f5641155bbb4eae60a7ede6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_LEFT_PAGE&#160;&#160;&#160;((uint32_t)nvmStorageLeft)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the absolute address of the LEFT page. </p>
<p>LEFT page storage is defined by nvmStorageLeft[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM". </p>

<p>Definition at line <a class="el" href="a01169_source.html#l00263">263</a> of file <a class="el" href="a01169_source.html">nvm.h</a>.</p>

<p>Referenced by <a class="el" href="a01167_source.html#l00158">halCommonGetAddressFromNvm()</a>, <a class="el" href="a01167_source.html#l00098">halCommonReadFromNvm()</a>, and <a class="el" href="a01167_source.html#l00280">halCommonWriteToNvm()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8953aab91c6b245cd9c0f03fe88d4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_MGMT_SIZE_B&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the number of bytes that comprise the NVM management bytes. </p>
<p>All data must begin at an offset above the management bytes.</p>
<dl class="section note"><dt>Note</dt><dd>This value <b>must not change</b>. </dd></dl>

<p>Definition at line <a class="el" href="a01169_source.html#l00278">278</a> of file <a class="el" href="a01169_source.html">nvm.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac6d032a9b1418fc2378f7dd35df05738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_RIGHT_PAGE&#160;&#160;&#160;((uint32_t)nvmStorageRight)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the absolute address of the RIGHT page. </p>
<p>RIGHT page storage is defined by nvmStorageRight[NVM_DATA_SIZE_B] and placed by the linker using the segment "NVM". </p>

<p>Definition at line <a class="el" href="a01169_source.html#l00270">270</a> of file <a class="el" href="a01169_source.html">nvm.h</a>.</p>

<p>Referenced by <a class="el" href="a01167_source.html#l00158">halCommonGetAddressFromNvm()</a>, <a class="el" href="a01167_source.html#l00098">halCommonReadFromNvm()</a>, and <a class="el" href="a01167_source.html#l00280">halCommonWriteToNvm()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafafd619bfdb67ff71b389c2fdbd59785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t* halCommonGetAddressFromNvm </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the address of the token in NVM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The location offset from which the address should be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address requested </dd></dl>

<p>Definition at line <a class="el" href="a01167_source.html#l00158">158</a> of file <a class="el" href="a01167_source.html">nvm.c</a>.</p>

<p>References <a class="el" href="a01167_source.html#l00280">halCommonWriteToNvm()</a>, <a class="el" href="a01169_source.html#l00263">NVM_LEFT_PAGE</a>, and <a class="el" href="a01169_source.html#l00270">NVM_RIGHT_PAGE</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c0e291bd7439de367cf9ec7fc2e8b01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StStatus halCommonReadFromNvm </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the NVM data from flash into the provided RAM location. </p>
<p>It is illegal for the offset to be greater than NVM_DATA_SIZE_B.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A (RAM) pointer to where the data should be copied.</td></tr>
    <tr><td class="paramname">offset</td><td>The location from which the data should be copied. Must be 16bit aligned.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the data in bytes. Must be 16bit aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An StStatus value indicating the success of the function.<ul>
<li>ST_SUCCESS if the read completed cleanly.</li>
<li>ST_ERR_FATAL if the NVM storage management indicated an invalid state. The function will return entirely 0xFF in the data parameter. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a01167_source.html#l00098">98</a> of file <a class="el" href="a01167_source.html">nvm.c</a>.</p>

<p>References <a class="el" href="a01169_source.html#l00253">NVM_DATA_SIZE_B</a>, <a class="el" href="a01169_source.html#l00263">NVM_LEFT_PAGE</a>, and <a class="el" href="a01169_source.html#l00270">NVM_RIGHT_PAGE</a>.</p>

</div>
</div>
<a class="anchor" id="gaa106c8d6e88a6224f232fe5824cca9f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StStatus halCommonWriteToNvm </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the NVM data from the provided location RAM into flash. </p>
<p>It is illegal for the offset to be greater than NVM_DATA_SIZE_B.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A (RAM) pointer from where the data should be taken.</td></tr>
    <tr><td class="paramname">offset</td><td>The location to which the data should be written. Must be 16bit aligned.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the data in bytes. Must be 16bit aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An StStatus value indicating the success of the function.<ul>
<li>ST_SUCCESS if the write completed cleanly.</li>
<li>Any other status value is an error code generated by the low level flash erase and write API. Refer to flash.h for details. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a01167_source.html#l00280">280</a> of file <a class="el" href="a01167_source.html">nvm.c</a>.</p>

<p>References <a class="el" href="a01169_source.html#l00253">NVM_DATA_SIZE_B</a>, <a class="el" href="a01169_source.html#l00263">NVM_LEFT_PAGE</a>, <a class="el" href="a01169_source.html#l00270">NVM_RIGHT_PAGE</a>, and <a class="el" href="a01200_source.html#l00175">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a01167_source.html#l00158">halCommonGetAddressFromNvm()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 24 2014 16:26:18 for Contiki-Inga 3.x by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
