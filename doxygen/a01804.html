<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Contiki-Inga 3.x: cc2538 Low Power Modes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-Inga 3.x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cc2538 Low Power Modes<div class="ingroups"><a class="el" href="a01799.html">The cc2538 Development Kit platform</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver for the cc2538 power modes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00893"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html">lpm.c</a></td></tr>
<tr class="memdesc:a00893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of low power modes ofr the cc2538. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00746"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00746.html">lpm.h</a></td></tr>
<tr class="memdesc:a00746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file with register, macro and function declarations for the cc2538 low power module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa8ae14246c9df775c53eeb9b54a7e8a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8ae14246c9df775c53eeb9b54a7e8a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01804.html#gaa8ae14246c9df775c53eeb9b54a7e8a8">lpm_init</a>(void)</td></tr>
<tr class="memdesc:gaa8ae14246c9df775c53eeb9b54a7e8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the LPM module. <br/></td></tr>
<tr class="separator:gaa8ae14246c9df775c53eeb9b54a7e8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55803916391d0a022c7e1315d0f10e1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01804.html#ga55803916391d0a022c7e1315d0f10e1d">lpm_enter</a>(void)</td></tr>
<tr class="memdesc:ga55803916391d0a022c7e1315d0f10e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop to Deep Sleep.  <a href="#ga55803916391d0a022c7e1315d0f10e1d">More...</a><br/></td></tr>
<tr class="separator:ga55803916391d0a022c7e1315d0f10e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4138a502282e17470a3e94c6c386fa26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01804.html#ga4138a502282e17470a3e94c6c386fa26">lpm_exit</a>(void)</td></tr>
<tr class="memdesc:ga4138a502282e17470a3e94c6c386fa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an 'Exit Deep Sleep' sequence.  <a href="#ga4138a502282e17470a3e94c6c386fa26">More...</a><br/></td></tr>
<tr class="separator:ga4138a502282e17470a3e94c6c386fa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga22d80fffc0d4fb26a7daa6296cf1412a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01804.html#ga22d80fffc0d4fb26a7daa6296cf1412a">lpm_set_max_pm</a> (uint8_t pm)</td></tr>
<tr class="memdesc:ga22d80fffc0d4fb26a7daa6296cf1412a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent the SoC from dropping to a PM higher than <em>max_pm</em>.  <a href="#ga22d80fffc0d4fb26a7daa6296cf1412a">More...</a><br/></td></tr>
<tr class="separator:ga22d80fffc0d4fb26a7daa6296cf1412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a147f44618f879db0ebd14d4d302d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01804.html#ga8a147f44618f879db0ebd14d4d302d99">lpm_register_peripheral</a> (lpm_periph_permit_pm1_func_t permit_pm1_func)</td></tr>
<tr class="memdesc:ga8a147f44618f879db0ebd14d4d302d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a peripheral function which will get called by the LPM module to get 'permission' to drop to PM1+.  <a href="#ga8a147f44618f879db0ebd14d4d302d99">More...</a><br/></td></tr>
<tr class="separator:ga8a147f44618f879db0ebd14d4d302d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LPM stats</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp69257a1097062693ea91e8fa5a08fc1f"></a>Maintains a record of how many rtimer ticks spent in each Power Mode.</p>
<p>Mainly used for debugging the module </p>
</td></tr>
<tr class="memitem:ga20d46b46e5c3d20610c2c77bd13c2519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20d46b46e5c3d20610c2c77bd13c2519"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LPM_STATS_GET</b>(pm)</td></tr>
<tr class="separator:ga20d46b46e5c3d20610c2c77bd13c2519"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constants to be used as arguments to lpm_set_max_pm()</h2></td></tr>
<tr class="memitem:ga38a22d0661f1a3e47d8041aa3ac4c183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38a22d0661f1a3e47d8041aa3ac4c183"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LPM_PM0</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga38a22d0661f1a3e47d8041aa3ac4c183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28539d202e7388ff8a30264f4e9a16f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28539d202e7388ff8a30264f4e9a16f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LPM_PM1</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga28539d202e7388ff8a30264f4e9a16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f627830cb8c910dbbbee2c8c5b3f03e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f627830cb8c910dbbbee2c8c5b3f03e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LPM_PM2</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga3f627830cb8c910dbbbee2c8c5b3f03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the cc2538 power modes. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga55803916391d0a022c7e1315d0f10e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop to Deep Sleep. </p>
<p>This function triggers a sequence to enter Deep Sleep. The sequence involves determining the most suitable PM and switching the system clock source to the 16MHz if required. If the energest module is enabled, the sequence also performs some simple energest calculations.</p>
<p>Broadly speaking, this function will be called from the main loop when all events have been serviced. This functions aims to be clever enough in order to be able to choose between PMs 0/1/2 depending on chip status and anticipated sleep duration. This choice is made subject to configuration restrictions and subject to restrictions imposed by calls to <a class="el" href="a01804.html#ga22d80fffc0d4fb26a7daa6296cf1412a" title="Prevent the SoC from dropping to a PM higher than max_pm.">lpm_set_max_pm()</a>.</p>
<p>This PM selection heuristic has the following primary criteria:</p>
<ul>
<li>Is the RF off?</li>
<li>Are all registered peripherals permitting PM1+?</li>
<li>Is the Sleep Timer scheduled to fire an interrupt?</li>
</ul>
<p>If the answer to any of those questions is no, we will drop to PM0 and will wake up to any interrupt. Best case scenario (if nothing else happens), we will idle until the next SysTick in no more than 1000/CLOCK_SECOND ms (7.8125ms).</p>
<p>If all can be answered with 'yes', we can drop to PM1/2 knowing that the Sleep Timer will wake us up. Depending on the estimated deep sleep duration and the max PM allowed by user configuration, we select the most efficient Power Mode to drop to. If the duration is too short, we simply IDLE in PM0.</p>
<p>Dropping to PM1/2 requires a switch to the 16MHz OSC. We have the option of letting the SoC do this for us automatically. However, if an interrupt fires during this automatic switch, we will need to re-assert WFI. To avoid this complexity, we perform the switch to the 16MHz OSC manually in software and we assert WFI after the transition has been completed. This gives us a chance to bail out if an interrupt fires or an event is raised during the transition. If nothing happens, dropping to PM1+ is un-interruptible and with a deterministic duration. When we wake up, we switch back to the 32MHz OSC manually before handing control back to main. This is implemented in <a class="el" href="a01804.html#ga4138a502282e17470a3e94c6c386fa26" title="Perform an &#39;Exit Deep Sleep&#39; sequence.">lpm_exit()</a>, which will always be called from within the Sleep Timer ISR context.</p>
<dl class="section note"><dt>Note</dt><dd>Dropping to PM2 means that data in the SRAM non-retention area will be lost. It is recommended to disable PM2 if the total RAM footprint is larger than what will fit in the retention area. .nrdata* sections can be used to place uninitialized data in the SRAM non-retention area.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01799.html#ga840291bc02cba5474a4cb46a9b9566fe" title="Main routine for the cc2538dk platform.">main()</a>, <a class="el" href="a01806.html#ga27bd31b76f1f5952b1fb9043d56818a1" title="Get the time of the next scheduled rtimer trigger.">rtimer_arch_next_trigger()</a>, <a class="el" href="a01804.html#ga4138a502282e17470a3e94c6c386fa26" title="Perform an &#39;Exit Deep Sleep&#39; sequence.">lpm_exit()</a>, <a class="el" href="a01804.html#ga22d80fffc0d4fb26a7daa6296cf1412a" title="Prevent the SoC from dropping to a PM higher than max_pm.">lpm_set_max_pm()</a> </dd></dl>

<p>Definition at line <a class="el" href="a00746_source.html#l00212">212</a> of file <a class="el" href="a00746_source.html">lpm.h</a>.</p>

<p>Referenced by <a class="el" href="a01379_source.html#l00127">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4138a502282e17470a3e94c6c386fa26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an 'Exit Deep Sleep' sequence. </p>
<p>This routine is called from within the context of the ISR that caused us to come out of PM1/2. It performs a wake up sequence to make sure the 32MHz OSC is back on and the system clock is sourced on it.</p>
<p>While in PMs 1 and 2, the system clock stops ticking. This functions adjusts it when we wake up.</p>
<p>We always exit PM1/2 as a result of a scheduled rtimer task or a GPIO interrupt. This may lead to other parts of the code trying to use the RF, so we need to switch the clock source <em>before</em> said code gets executed.</p>
<p>This function also makes sure that the sleep timer value is up-to-date following wake-up from PM1/2 so that <a class="el" href="a01678.html#gae646864933baa81ca646c96fa6f9f803" title="Get the current clock time.">RTIMER_NOW()</a> works.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called at the very beginning of ISRs waking up the SoC in order to restore all clocks and timers.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01804.html#ga55803916391d0a022c7e1315d0f10e1d" title="Drop to Deep Sleep.">lpm_enter()</a>, rtimer_isr() </dd></dl>

<p>Definition at line <a class="el" href="a00746_source.html#l00213">213</a> of file <a class="el" href="a00746_source.html">lpm.h</a>.</p>

<p>Referenced by <a class="el" href="a00806_source.html#l00084">gpio_port_a_isr()</a>, <a class="el" href="a00806_source.html#l00100">gpio_port_b_isr()</a>, <a class="el" href="a00806_source.html#l00116">gpio_port_c_isr()</a>, <a class="el" href="a00806_source.html#l00132">gpio_port_d_isr()</a>, and <a class="el" href="a00995_source.html#l00137">rtimer_isr()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8a147f44618f879db0ebd14d4d302d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_register_peripheral </td>
          <td>(</td>
          <td class="paramtype">lpm_periph_permit_pm1_func_t&#160;</td>
          <td class="paramname"><em>permit_pm1_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a peripheral function which will get called by the LPM module to get 'permission' to drop to PM1+. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permit_pm1_func</td><td>Pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>Some peripherals are sensitive to PM changes. For instance, we don't want to drop to PM1+ if the USB PLL is active or if the UART TX FIFO is not clear.</p>
<p>When changing power modes, the LPM driver will call all FPs registered with this function. The peripheral's function will return true or false to permit / prohibit PM1+ respectively. If at least one peripheral returns false, the SoC will drop to PM0 Deep Sleep instead.</p>
<p>Registering several times the same function makes the LPM module behave as if the function had been registered once. </p>

<p>Referenced by <a class="el" href="a01190_source.html#l00122">uart_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga22d80fffc0d4fb26a7daa6296cf1412a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_set_max_pm </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent the SoC from dropping to a PM higher than <em>max_pm</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pm</td><td>The highest PM we are allowed to enter, specified as a number in [0, 2]</td></tr>
  </table>
  </dd>
</dl>
<p>Defines for the <em>pm</em> argument are LPM_PMx.</p>
<p>This function can be used by software in situations where some power modes are undesirable. If, for example, an application needs to avoid PM2, it would call lpm_set_max_pm(LPM_PM1). If an application wants to avoid PM1 as well, it would call lpm_set_max_pm(LPM_PM0)</p>
<p>PM0 can not be disabled at runtime. Use LPM_CONF_ENABLE to disable LPM support altogether</p>
<dl class="section note"><dt>Note</dt><dd>If the value of argument <em>pm</em> is greater than the value of the LPM_CONF_MAX_PM configuration directive, LPM_CONF_MAX_PM is used. Thus if LPM_CONF_MAX_PM==1, calling lpm_set_max_pm(LPM_PM2) would result in a maximum PM set to 1 and all subsequent Deep Sleeps would be limited to either PM0 or PM1.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01804.html#ga55803916391d0a022c7e1315d0f10e1d" title="Drop to Deep Sleep.">lpm_enter()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 24 2014 16:26:19 for Contiki-Inga 3.x by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
