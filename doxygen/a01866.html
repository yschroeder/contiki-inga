<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Contiki-Inga 3.x: The uIP TCP/IP stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-Inga 3.x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">The uIP TCP/IP stack<div class="ingroups"><a class="el" href="a01872.html">Communication stacks</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The uIP TCP/IP stack provides Internet communication abilities to Contiki.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a01689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01689.html">uIP packet forwarding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01690"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01690.html">uIP Address Resolution Protocol</a></td></tr>
<tr class="memdesc:a01690"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Address Resolution Protocol ARP is used for mapping between IP addresses and link level addresses such as the Ethernet MAC addresses. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01717"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01717.html">Protosockets library</a></td></tr>
<tr class="memdesc:a01717"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protosocket library provides an interface to the uIP stack that is similar to the traditional BSD socket interface. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01718"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01718.html">uIP hostname resolver functions</a></td></tr>
<tr class="memdesc:a01718"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP DNS resolver functions are used to lookup a hostname and map it to a numerical IP address. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01719"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01719.html">Simple-udp</a></td></tr>
<tr class="memdesc:a01719"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default Contiki UDP API is difficult to use. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01720"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01720.html">Serial Line IP (SLIP) protocol</a></td></tr>
<tr class="memdesc:a01720"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SLIP protocol is a very simple way to transmit IP packets over a serial line. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01721"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html">The Contiki/uIP interface</a></td></tr>
<tr class="memdesc:a01721"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP/IP support in Contiki is implemented using the uIP TCP/IP stack. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01722"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01722.html">uIP TCP throughput booster hack</a></td></tr>
<tr class="memdesc:a01722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basic uIP TCP implementation only allows each TCP connection to have a single TCP segment in flight at any given time. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01723"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01723.html">uIP configuration functions</a></td></tr>
<tr class="memdesc:a01723"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP configuration functions are used for setting run-time parameters in uIP such as IP addresses. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01724"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01724.html">uIP initialization functions</a></td></tr>
<tr class="memdesc:a01724"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP initialization functions are used for booting uIP. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01725"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01725.html">uIP device driver functions</a></td></tr>
<tr class="memdesc:a01725"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions are used by a network device driver for interacting with uIP. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01726.html">uIP application functions</a></td></tr>
<tr class="memdesc:a01726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions used by an application running of top of uIP. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01727.html">uIP conversion functions</a></td></tr>
<tr class="memdesc:a01727"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be used for converting between different data formats used by uIP. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01728"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01728.html">Variables used in uIP device drivers</a></td></tr>
<tr class="memdesc:a01728"><td class="mdescLeft">&#160;</td><td class="mdescRight">uIP has a few global variables that are used in device drivers for uIP. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01730.html">Configuration options for uIP</a></td></tr>
<tr class="memdesc:a01730"><td class="mdescLeft">&#160;</td><td class="mdescRight">uIP is configured using the per-project configuration file "uipopt.h". <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01875.html">6LoWPAN implementation</a></td></tr>
<tr class="memdesc:a01875"><td class="mdescLeft">&#160;</td><td class="mdescRight">6lowpan is a Working Group in IETF which defines the use of IPv6 on IEEE 802.15.4 links. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01876"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01876.html">uIP IPv6 specific features</a></td></tr>
<tr class="memdesc:a01876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP IPv6 stack provides new Internet communication abilities to Contiki. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01729"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01729.html">Architecture specific uIP functions</a></td></tr>
<tr class="memdesc:a01729"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions in the architecture specific module implement the IP check sum and 32-bit additions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00303"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html">uip.c</a></td></tr>
<tr class="memdesc:a00303"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP TCP/IP stack code. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00285"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html">uip.h</a></td></tr>
<tr class="memdesc:a00285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file for the uIP TCP/IP stack. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">uip_ip4addr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an IP address.  <a href="a00124.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">uip_802154_shortaddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bit 802.15.4 address  <a href="a00106.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">uip_802154_longaddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64 bit 802.15.4 address  <a href="a00105.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">uip_80211_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">802.11 address  <a href="a00104.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">uip_eth_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">802.3 address  <a href="a00120.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">uip_conn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a uIP TCP connection.  <a href="a00108.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">uip_udp_conn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a uIP UDP connection.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">uip_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure holding the TCP/IP statistics that are gathered if UIP_STATISTICS is set to 1.  <a href="a00134.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga488258fa3fa2856c84a9884842423086"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga488258fa3fa2856c84a9884842423086">uip_l2_l3_hdr_len</a>&#160;&#160;&#160;(<a class="el" href="a01732.html#gae6f4a2453dbd8bc60e6a82774552366a">UIP_LLH_LEN</a> + UIP_IPH_LEN + <a class="el" href="a01876.html#ga0c63b80e0f8038403df5fee2bac3aab8">uip_ext_len</a>)</td></tr>
<tr class="memdesc:ga488258fa3fa2856c84a9884842423086"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sums below are quite used in ND.  <a href="#ga488258fa3fa2856c84a9884842423086">More...</a><br/></td></tr>
<tr class="separator:ga488258fa3fa2856c84a9884842423086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0814ed491fa452ec97910c0728d410"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga9c0814ed491fa452ec97910c0728d410">UIP_STAT</a>(s)</td></tr>
<tr class="memdesc:ga9c0814ed491fa452ec97910c0728d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP TCP/IP statistics.  <a href="#ga9c0814ed491fa452ec97910c0728d410">More...</a><br/></td></tr>
<tr class="separator:ga9c0814ed491fa452ec97910c0728d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0825474feee11b4e038bfe71757875f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gae0825474feee11b4e038bfe71757875f">UIP_APPDATA_SIZE</a></td></tr>
<tr class="memdesc:gae0825474feee11b4e038bfe71757875f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer size available for user data in the uip_buf buffer.  <a href="#gae0825474feee11b4e038bfe71757875f">More...</a><br/></td></tr>
<tr class="separator:gae0825474feee11b4e038bfe71757875f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef3b86072ede74820ad3df6392e0595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ef3b86072ede74820ad3df6392e0595"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga8ef3b86072ede74820ad3df6392e0595">UIP_LLPREF_LEN</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga8ef3b86072ede74820ad3df6392e0595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the link local prefix. <br/></td></tr>
<tr class="separator:ga8ef3b86072ede74820ad3df6392e0595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5307b094bee02bd01024ed614454ba6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5307b094bee02bd01024ed614454ba6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaf5307b094bee02bd01024ed614454ba6">uip_is_addr_loopback</a>(a)</td></tr>
<tr class="memdesc:gaf5307b094bee02bd01024ed614454ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is IPv6 address a the unspecified address a is of type uip_ipaddr_t. <br/></td></tr>
<tr class="separator:gaf5307b094bee02bd01024ed614454ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6431471582024cef5dcb2b062af72c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d6431471582024cef5dcb2b062af72c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga4d6431471582024cef5dcb2b062af72c">uip_is_addr_unspecified</a>(a)</td></tr>
<tr class="memdesc:ga4d6431471582024cef5dcb2b062af72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is IPv6 address a the unspecified address a is of type uip_ipaddr_t. <br/></td></tr>
<tr class="separator:ga4d6431471582024cef5dcb2b062af72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac466f1ba30db59ed368582dba6add0a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac466f1ba30db59ed368582dba6add0a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gac466f1ba30db59ed368582dba6add0a0">uip_is_addr_linklocal_allnodes_mcast</a>(a)</td></tr>
<tr class="memdesc:gac466f1ba30db59ed368582dba6add0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is IPv6 address a the link local all-nodes multicast address. <br/></td></tr>
<tr class="separator:gac466f1ba30db59ed368582dba6add0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba58f549e843719a8ab8dbd102decb92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba58f549e843719a8ab8dbd102decb92"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaba58f549e843719a8ab8dbd102decb92">uip_is_addr_linklocal_allrouters_mcast</a>(a)</td></tr>
<tr class="memdesc:gaba58f549e843719a8ab8dbd102decb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is IPv6 address a the link local all-routers multicast address. <br/></td></tr>
<tr class="separator:gaba58f549e843719a8ab8dbd102decb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8b0e871e3e46072cf7672778972521"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaab8b0e871e3e46072cf7672778972521">uip_is_addr_linklocal</a>(a)</td></tr>
<tr class="memdesc:gaab8b0e871e3e46072cf7672778972521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the address a is link local.  <a href="#gaab8b0e871e3e46072cf7672778972521">More...</a><br/></td></tr>
<tr class="separator:gaab8b0e871e3e46072cf7672778972521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1575eb503935345b73ce708b33f3176d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1575eb503935345b73ce708b33f3176d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga1575eb503935345b73ce708b33f3176d">uip_create_unspecified</a>(a)&#160;&#160;&#160;<a class="el" href="a01727.html#ga53fbda0e8c31d4882294c8dc3cb5f487">uip_ip6addr</a>(a, 0, 0, 0, 0, 0, 0, 0, 0)</td></tr>
<tr class="memdesc:ga1575eb503935345b73ce708b33f3176d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set IP address a to unspecified <br/></td></tr>
<tr class="separator:ga1575eb503935345b73ce708b33f3176d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdbb1f37d0fc34589bb2038ebb16a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaefdbb1f37d0fc34589bb2038ebb16a10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaefdbb1f37d0fc34589bb2038ebb16a10">uip_create_linklocal_allnodes_mcast</a>(a)&#160;&#160;&#160;<a class="el" href="a01727.html#ga53fbda0e8c31d4882294c8dc3cb5f487">uip_ip6addr</a>(a, 0xff02, 0, 0, 0, 0, 0, 0, 0x0001)</td></tr>
<tr class="memdesc:gaefdbb1f37d0fc34589bb2038ebb16a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">set IP address a to the link local all-nodes multicast address <br/></td></tr>
<tr class="separator:gaefdbb1f37d0fc34589bb2038ebb16a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021225297f365f18d3f643dc79786ae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga021225297f365f18d3f643dc79786ae8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga021225297f365f18d3f643dc79786ae8">uip_create_linklocal_allrouters_mcast</a>(a)&#160;&#160;&#160;<a class="el" href="a01727.html#ga53fbda0e8c31d4882294c8dc3cb5f487">uip_ip6addr</a>(a, 0xff02, 0, 0, 0, 0, 0, 0, 0x0002)</td></tr>
<tr class="memdesc:ga021225297f365f18d3f643dc79786ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set IP address a to the link local all-routers multicast address <br/></td></tr>
<tr class="separator:ga021225297f365f18d3f643dc79786ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21400a7a6f53a42e24b86d6bd43d5b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab21400a7a6f53a42e24b86d6bd43d5b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gab21400a7a6f53a42e24b86d6bd43d5b2">uip_is_addr_solicited_node</a>(a)</td></tr>
<tr class="memdesc:gab21400a7a6f53a42e24b86d6bd43d5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">is addr (a) a solicited node multicast address, see RFC3513 a is of type uip_ipaddr_t* <br/></td></tr>
<tr class="separator:gab21400a7a6f53a42e24b86d6bd43d5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa391d2ec4bb208ee037c8cf81633eee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa391d2ec4bb208ee037c8cf81633eee8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaa391d2ec4bb208ee037c8cf81633eee8">uip_create_solicited_node</a>(a, b)</td></tr>
<tr class="memdesc:gaa391d2ec4bb208ee037c8cf81633eee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">in b the solicited node address corresponding to address a both a and b are of type uip_ipaddr_t* <br/></td></tr>
<tr class="separator:gaa391d2ec4bb208ee037c8cf81633eee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936d474f1896bf364c717eb536ecf0e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga936d474f1896bf364c717eb536ecf0e3">uip_is_addr_link_local</a>(a)</td></tr>
<tr class="memdesc:ga936d474f1896bf364c717eb536ecf0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">is addr (a) a link local unicast address, see RFC3513 i.e.  <a href="#ga936d474f1896bf364c717eb536ecf0e3">More...</a><br/></td></tr>
<tr class="separator:ga936d474f1896bf364c717eb536ecf0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddefceeaf73b847319dd4f6e579fd7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ddefceeaf73b847319dd4f6e579fd7d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga1ddefceeaf73b847319dd4f6e579fd7d">uip_is_addr_mac_addr_based</a>(a, m)</td></tr>
<tr class="memdesc:ga1ddefceeaf73b847319dd4f6e579fd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">was addr (a) forged based on the mac address m a type is uip_ipaddr_t m type is uiplladdr_t <br/></td></tr>
<tr class="separator:ga1ddefceeaf73b847319dd4f6e579fd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a264ba26cdd3286c96fce7f854b0aa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a264ba26cdd3286c96fce7f854b0aa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga7a264ba26cdd3286c96fce7f854b0aa1">uip_is_addr_mcast</a>(a)&#160;&#160;&#160;(((a)-&gt;u8[0]) == 0xFF)</td></tr>
<tr class="memdesc:ga7a264ba26cdd3286c96fce7f854b0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">is address a multicast address, see RFC 3513 a is of type uip_ipaddr_t* <br/></td></tr>
<tr class="separator:ga7a264ba26cdd3286c96fce7f854b0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c1e1634aea09be99fb17a23ec95e78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9c1e1634aea09be99fb17a23ec95e78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gac9c1e1634aea09be99fb17a23ec95e78">uip_is_addr_mcast_global</a>(a)</td></tr>
<tr class="memdesc:gac9c1e1634aea09be99fb17a23ec95e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">is address a global multicast address (FFxE::/16), a is of type uip_ip6addr_t* <br/></td></tr>
<tr class="separator:gac9c1e1634aea09be99fb17a23ec95e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dafb9c2d4f98a72346c5c3e18dd3559"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga5dafb9c2d4f98a72346c5c3e18dd3559">uip_is_addr_mcast_non_routable</a>(a)</td></tr>
<tr class="memdesc:ga5dafb9c2d4f98a72346c5c3e18dd3559"><td class="mdescLeft">&#160;</td><td class="mdescRight">is address a non-routable multicast address.  <a href="#ga5dafb9c2d4f98a72346c5c3e18dd3559">More...</a><br/></td></tr>
<tr class="separator:ga5dafb9c2d4f98a72346c5c3e18dd3559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410e205fa84ee79b9c17c7ab112d71f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga410e205fa84ee79b9c17c7ab112d71f4">uip_is_addr_mcast_routable</a>(a)</td></tr>
<tr class="memdesc:ga410e205fa84ee79b9c17c7ab112d71f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">is address a routable multicast address.  <a href="#ga410e205fa84ee79b9c17c7ab112d71f4">More...</a><br/></td></tr>
<tr class="separator:ga410e205fa84ee79b9c17c7ab112d71f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4099928fec8f1e1402367c034bd23f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e4099928fec8f1e1402367c034bd23f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga9e4099928fec8f1e1402367c034bd23f">uip_is_mcast_group_id_all_nodes</a>(a)</td></tr>
<tr class="memdesc:ga9e4099928fec8f1e1402367c034bd23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">is group-id of multicast address a the all nodes group-id <br/></td></tr>
<tr class="separator:ga9e4099928fec8f1e1402367c034bd23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022b7caa514b17d07f107842c5340c66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga022b7caa514b17d07f107842c5340c66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga022b7caa514b17d07f107842c5340c66">uip_is_mcast_group_id_all_routers</a>(a)</td></tr>
<tr class="memdesc:ga022b7caa514b17d07f107842c5340c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">is group-id of multicast address a the all routers group-id <br/></td></tr>
<tr class="separator:ga022b7caa514b17d07f107842c5340c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ffcfb2a5a9f3deceaf897ac13d33fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga37ffcfb2a5a9f3deceaf897ac13d33fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga37ffcfb2a5a9f3deceaf897ac13d33fe">uip_are_solicited_bytes_equal</a>(a, b)</td></tr>
<tr class="memdesc:ga37ffcfb2a5a9f3deceaf897ac13d33fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">are last three bytes of both addresses equal? This is used to compare solicited node multicast addresses <br/></td></tr>
<tr class="separator:ga37ffcfb2a5a9f3deceaf897ac13d33fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafcda3f09d42c591ef794e7e0939a5e0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafcda3f09d42c591ef794e7e0939a5e0d"></a>
typedef union <a class="el" href="a00124.html">uip_ip4addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gafcda3f09d42c591ef794e7e0939a5e0d">uip_ip4addr_t</a></td></tr>
<tr class="memdesc:gafcda3f09d42c591ef794e7e0939a5e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an IP address. <br/></td></tr>
<tr class="separator:gafcda3f09d42c591ef794e7e0939a5e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa19f46c8c1df26f52a3e29e076a6f485"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa19f46c8c1df26f52a3e29e076a6f485"></a>
typedef struct <a class="el" href="a00106.html">uip_802154_shortaddr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaa19f46c8c1df26f52a3e29e076a6f485">uip_802154_shortaddr</a></td></tr>
<tr class="memdesc:gaa19f46c8c1df26f52a3e29e076a6f485"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bit 802.15.4 address <br/></td></tr>
<tr class="separator:gaa19f46c8c1df26f52a3e29e076a6f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6602e7d93f6c640707ab765f0c10e74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6602e7d93f6c640707ab765f0c10e74"></a>
typedef struct <a class="el" href="a00105.html">uip_802154_longaddr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gad6602e7d93f6c640707ab765f0c10e74">uip_802154_longaddr</a></td></tr>
<tr class="memdesc:gad6602e7d93f6c640707ab765f0c10e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">64 bit 802.15.4 address <br/></td></tr>
<tr class="separator:gad6602e7d93f6c640707ab765f0c10e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5e417f029947c4101818b10a59b90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd5e417f029947c4101818b10a59b90c"></a>
typedef struct <a class="el" href="a00104.html">uip_80211_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gafd5e417f029947c4101818b10a59b90c">uip_80211_addr</a></td></tr>
<tr class="memdesc:gafd5e417f029947c4101818b10a59b90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">802.11 address <br/></td></tr>
<tr class="separator:gafd5e417f029947c4101818b10a59b90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2261bf70c777f913cfefef920e57ed36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2261bf70c777f913cfefef920e57ed36"></a>
typedef struct <a class="el" href="a00120.html">uip_eth_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga2261bf70c777f913cfefef920e57ed36">uip_eth_addr</a></td></tr>
<tr class="memdesc:ga2261bf70c777f913cfefef920e57ed36"><td class="mdescLeft">&#160;</td><td class="mdescRight">802.3 address <br/></td></tr>
<tr class="separator:ga2261bf70c777f913cfefef920e57ed36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239a73d412e4d6ce81473305919856cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga239a73d412e4d6ce81473305919856cc"></a>
typedef <a class="el" href="a00120.html">uip_eth_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga239a73d412e4d6ce81473305919856cc">uip_lladdr_t</a></td></tr>
<tr class="memdesc:ga239a73d412e4d6ce81473305919856cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ethernet address. <br/></td></tr>
<tr class="separator:ga239a73d412e4d6ce81473305919856cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4c90e268d83fc6cd9cd78bfa435b8140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga4c90e268d83fc6cd9cd78bfa435b8140">uip_process</a> (uint8_t flag)</td></tr>
<tr class="memdesc:ga4c90e268d83fc6cd9cd78bfa435b8140"><td class="mdescLeft">&#160;</td><td class="mdescRight">process the options within a hop by hop or destination option header  <a href="#ga4c90e268d83fc6cd9cd78bfa435b8140">More...</a><br/></td></tr>
<tr class="separator:ga4c90e268d83fc6cd9cd78bfa435b8140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9287706e35d5fb2080d1f6f14551f76f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga9287706e35d5fb2080d1f6f14551f76f">uip_chksum</a> (uint16_t *buf, uint16_t len)</td></tr>
<tr class="memdesc:ga9287706e35d5fb2080d1f6f14551f76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Internet checksum over a buffer.  <a href="#ga9287706e35d5fb2080d1f6f14551f76f">More...</a><br/></td></tr>
<tr class="separator:ga9287706e35d5fb2080d1f6f14551f76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707e869bd80c32239d214a8ebe560c04"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga707e869bd80c32239d214a8ebe560c04">uip_ipchksum</a> (void)</td></tr>
<tr class="memdesc:ga707e869bd80c32239d214a8ebe560c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the IP header checksum of the packet header in uip_buf.  <a href="#ga707e869bd80c32239d214a8ebe560c04">More...</a><br/></td></tr>
<tr class="separator:ga707e869bd80c32239d214a8ebe560c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969ff8bccf86e1c4becc3c3fd23f93b4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga969ff8bccf86e1c4becc3c3fd23f93b4">uip_tcpchksum</a> (void)</td></tr>
<tr class="memdesc:ga969ff8bccf86e1c4becc3c3fd23f93b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the TCP checksum of the packet in uip_buf and uip_appdata.  <a href="#ga969ff8bccf86e1c4becc3c3fd23f93b4">More...</a><br/></td></tr>
<tr class="separator:ga969ff8bccf86e1c4becc3c3fd23f93b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb447241dcd4e7840ea4b0603fc2c330"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaeb447241dcd4e7840ea4b0603fc2c330">uip_udpchksum</a> (void)</td></tr>
<tr class="memdesc:gaeb447241dcd4e7840ea4b0603fc2c330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the UDP checksum of the packet in uip_buf and uip_appdata.  <a href="#gaeb447241dcd4e7840ea4b0603fc2c330">More...</a><br/></td></tr>
<tr class="separator:gaeb447241dcd4e7840ea4b0603fc2c330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec91f3c5d75781b5ad9915828aaeba9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga3ec91f3c5d75781b5ad9915828aaeba9">uip_icmp6chksum</a> (void)</td></tr>
<tr class="memdesc:ga3ec91f3c5d75781b5ad9915828aaeba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the ICMP checksum of the packet in uip_buf.  <a href="#ga3ec91f3c5d75781b5ad9915828aaeba9">More...</a><br/></td></tr>
<tr class="separator:ga3ec91f3c5d75781b5ad9915828aaeba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad5848369ab5b02f2fb02d8390ccbaf79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gad5848369ab5b02f2fb02d8390ccbaf79">uip_appdata</a></td></tr>
<tr class="memdesc:gad5848369ab5b02f2fb02d8390ccbaf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the application data in the packet buffer.  <a href="#gad5848369ab5b02f2fb02d8390ccbaf79">More...</a><br/></td></tr>
<tr class="separator:gad5848369ab5b02f2fb02d8390ccbaf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f4b1021e1a18d4d857ca8c121ec6e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00108.html">uip_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga76f4b1021e1a18d4d857ca8c121ec6e6">uip_conn</a></td></tr>
<tr class="memdesc:ga76f4b1021e1a18d4d857ca8c121ec6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the current TCP connection.  <a href="#ga76f4b1021e1a18d4d857ca8c121ec6e6">More...</a><br/></td></tr>
<tr class="separator:ga76f4b1021e1a18d4d857ca8c121ec6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210f227119fc972e6222c9cb452e15a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga210f227119fc972e6222c9cb452e15a9"></a>
struct <a class="el" href="a00135.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga210f227119fc972e6222c9cb452e15a9">uip_udp_conn</a></td></tr>
<tr class="memdesc:ga210f227119fc972e6222c9cb452e15a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current UDP connection. <br/></td></tr>
<tr class="separator:ga210f227119fc972e6222c9cb452e15a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bf167a9f1014d2d78754742eb7e06d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89bf167a9f1014d2d78754742eb7e06d"></a>
<a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> <a class="el" href="a01866.html#ga239a73d412e4d6ce81473305919856cc">uip_lladdr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga89bf167a9f1014d2d78754742eb7e06d">uip_lladdr</a></td></tr>
<tr class="memdesc:ga89bf167a9f1014d2d78754742eb7e06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Host L2 address. <br/></td></tr>
<tr class="separator:ga89bf167a9f1014d2d78754742eb7e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e4f4f473a763397b17d0550ddefc62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8e4f4f473a763397b17d0550ddefc62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gaf8e4f4f473a763397b17d0550ddefc62">UIP_PROTO_HBHO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf8e4f4f473a763397b17d0550ddefc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">extension headers types <br/></td></tr>
<tr class="separator:gaf8e4f4f473a763397b17d0550ddefc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8733993b47ab187373c9fcbe9a1f4555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8733993b47ab187373c9fcbe9a1f4555"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#ga8733993b47ab187373c9fcbe9a1f4555">UIP_EXT_HDR_OPT_PAD1</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga8733993b47ab187373c9fcbe9a1f4555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destination and Hop By Hop extension headers option types. <br/></td></tr>
<tr class="separator:ga8733993b47ab187373c9fcbe9a1f4555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63bbcf2f409069439613cd288355dd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01866.html#gae63bbcf2f409069439613cd288355dd2">UIP_EXT_HDR_BITMAP_HBHO</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:gae63bbcf2f409069439613cd288355dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmaps for extension header processing.  <a href="#gae63bbcf2f409069439613cd288355dd2">More...</a><br/></td></tr>
<tr class="separator:gae63bbcf2f409069439613cd288355dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The uIP TCP/IP stack provides Internet communication abilities to Contiki. </p>
<p>{@</p>
<h1><a class="anchor" id="uip-introduction"></a>
uIP introduction</h1>
<p>The uIP TCP/IP stack is intended to make it possible to communicate using the TCP/IP protocol suite even on small 8-bit micro-controllers. Despite being small and simple, uIP do not require their peers to have complex, full-size stacks, but can communicate with peers running a similarly light-weight stack. The code size is on the order of a few kilobytes and RAM usage can be configured to be as low as a few hundred bytes.</p>
<p>uIP can be found at the uIP web page: <a href="http://www.sics.se/~adam/uip/">http://www.sics.se/~adam/uip/</a></p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01721.html">The Contiki/uIP interface</a> </dd>
<dd>
<a class="el" href="a01876.html">uIP IPv6 specific features</a> and <a class="el" href="a01875.html" title="6lowpan is a Working Group in IETF which defines the use of IPv6 on IEEE 802.15.4 links...">6LoWPAN implementation</a> </dd>
<dd>
<a class="el" href="a01730.html">uIP Compile-time configuration options</a> </dd>
<dd>
<a class="el" href="a01723.html">uIP Run-time configuration functions</a> </dd>
<dd>
<a class="el" href="a01724.html">uIP initialization functions</a> </dd>
<dd>
<a class="el" href="a01725.html">uIP device driver interface</a> and <a class="el" href="a01728.html">uIP variables used by device drivers</a> </dd>
<dd>
<a class="el" href="a01726.html">uIP functions called from application programs</a> (see below) and the <a class="el" href="a01717.html">protosockets API</a> and their underlying <a class="el" href="a01871.html">protothreads</a></dd></dl>
<h1><a class="anchor" id="uIPIntroduction"></a>
Introduction</h1>
<p>With the success of the Internet, the TCP/IP protocol suite has become a global standard for communication. TCP/IP is the underlying protocol used for web page transfers, e-mail transmissions, file transfers, and peer-to-peer networking over the Internet. For embedded systems, being able to run native TCP/IP makes it possible to connect the system directly to an intranet or even the global Internet. Embedded devices with full TCP/IP support will be first-class network citizens, thus being able to fully communicate with other hosts in the network.</p>
<p>Traditional TCP/IP implementations have required far too much resources both in terms of code size and memory usage to be useful in small 8 or 16-bit systems. Code size of a few hundred kilobytes and RAM requirements of several hundreds of kilobytes have made it impossible to fit the full TCP/IP stack into systems with a few tens of kilobytes of RAM and room for less than 100 kilobytes of code.</p>
<p>The uIP implementation is designed to have only the absolute minimal set of features needed for a full TCP/IP stack. It can only handle a single network interface and contains the IP, ICMP, UDP and TCP protocols. uIP is written in the C programming language.</p>
<p>Many other TCP/IP implementations for small systems assume that the embedded device always will communicate with a full-scale TCP/IP implementation running on a workstation-class machine. Under this assumption, it is possible to remove certain TCP/IP mechanisms that are very rarely used in such situations. Many of those mechanisms are essential, however, if the embedded device is to communicate with another equally limited device, e.g., when running distributed peer-to-peer services and protocols. uIP is designed to be RFC compliant in order to let the embedded devices to act as first-class network citizens. The uIP TCP/IP implementation that is not tailored for any specific application.</p>
<h1><a class="anchor" id="uip-tcpip"></a>
TCP/IP Communication</h1>
<p>The full TCP/IP suite consists of numerous protocols, ranging from low level protocols such as ARP which translates IP addresses to MAC addresses, to application level protocols such as SMTP that is used to transfer e-mail. The uIP is mostly concerned with the TCP and IP protocols and upper layer protocols will be referred to as "the
application". Lower layer protocols are often implemented in hardware or firmware and will be referred to as "the network device" that are controlled by the network device driver.</p>
<p>TCP provides a reliable byte stream to the upper layer protocols. It breaks the byte stream into appropriately sized segments and each segment is sent in its own IP packet. The IP packets are sent out on the network by the network device driver. If the destination is not on the physically connected network, the IP packet is forwarded onto another network by a router that is situated between the two networks. If the maximum packet size of the other network is smaller than the size of the IP packet, the packet is fragmented into smaller packets by the router. If possible, the size of the TCP segments are chosen so that fragmentation is minimized. The final recipient of the packet will have to reassemble any fragmented IP packets before they can be passed to higher layers.</p>
<p>The formal requirements for the protocols in the TCP/IP stack is specified in a number of RFC documents published by the Internet Engineering Task Force, IETF. Each of the protocols in the stack is defined in one more RFC documents and RFC1122 collects all requirements and updates the previous RFCs.</p>
<p>The RFC1122 requirements can be divided into two categories; those that deal with the host to host communication and those that deal with communication between the application and the networking stack. An example of the first kind is "A TCP MUST be able to receive a TCP
option in any segment" and an example of the second kind is "There MUST be a mechanism for reporting soft TCP error conditions to the application." A TCP/IP implementation that violates requirements of the first kind may not be able to communicate with other TCP/IP implementations and may even lead to network failures. Violation of the second kind of requirements will only affect the communication within the system and will not affect host-to-host communication.</p>
<p>In uIP, all RFC requirements that affect host-to-host communication are implemented. However, in order to reduce code size, we have removed certain mechanisms in the interface between the application and the stack, such as the soft error reporting mechanism and dynamically configurable type-of-service bits for TCP connections. Since there are only very few applications that make use of those features they can be removed without loss of generality.</p>
<h1><a class="anchor" id="mainloop"></a>
Main Control Loop</h1>
<p>The uIP stack can be run either as a task in a multitasking system, or as the main program in a singletasking system. In both cases, the main control loop does two things repeatedly:</p>
<ul>
<li>Check if a packet has arrived from the network.</li>
<li>Check if a periodic timeout has occurred.</li>
</ul>
<p>If a packet has arrived, the input handler function, <a class="el" href="a01725.html#gaa4360412ee9350fba725f98a137169fe" title="Process an incoming packet.">uip_input()</a>, should be invoked by the main control loop. The input handler function will never block, but will return at once. When it returns, the stack or the application for which the incoming packet was intended may have produced one or more reply packets which should be sent out. If so, the network device driver should be called to send out these packets.</p>
<p>Periodic timeouts are used to drive TCP mechanisms that depend on timers, such as delayed acknowledgments, retransmissions and round-trip time estimations. When the main control loop infers that the periodic timer should fire, it should invoke the timer handler function uip_periodic(). Because the TCP/IP stack may perform retransmissions when dealing with a timer event, the network device driver should called to send out the packets that may have been produced.</p>
<h1><a class="anchor" id="arch"></a>
Architecture Specific Functions</h1>
<p>uIP requires a few functions to be implemented specifically for the architecture on which uIP is intended to run. These functions should be hand-tuned for the particular architecture, but generic C implementations are given as part of the uIP distribution.</p>
<h2><a class="anchor" id="checksums"></a>
Checksum Calculation</h2>
<p>The TCP and IP protocols implement a checksum that covers the data and header portions of the TCP and IP packets. Since the calculation of this checksum is made over all bytes in every packet being sent and received it is important that the function that calculates the checksum is efficient. Most often, this means that the checksum calculation must be fine-tuned for the particular architecture on which the uIP stack runs.</p>
<p>While uIP includes a generic checksum function, it also leaves it open for an architecture specific implementation of the two functions <a class="el" href="a01866.html#ga707e869bd80c32239d214a8ebe560c04" title="Calculate the IP header checksum of the packet header in uip_buf.">uip_ipchksum()</a> and <a class="el" href="a01866.html#ga969ff8bccf86e1c4becc3c3fd23f93b4" title="Calculate the TCP checksum of the packet in uip_buf and uip_appdata.">uip_tcpchksum()</a>. The checksum calculations in those functions can be written in highly optimized assembler rather than generic C code.</p>
<h2><a class="anchor" id="longarith"></a>
32-bit Arithmetic</h2>
<p>The TCP protocol uses 32-bit sequence numbers, and a TCP implementation will have to do a number of 32-bit additions as part of the normal protocol processing. Since 32-bit arithmetic is not natively available on many of the platforms for which uIP is intended, uIP leaves the 32-bit additions to be implemented by the architecture specific module and does not make use of any 32-bit arithmetic in the main code base.</p>
<p>While uIP implements a generic 32-bit addition, there is support for having an architecture specific implementation of the <a class="el" href="a01729.html#ga5a380cbebc834ec7aea86f6cfff7f19e" title="Carry out a 32-bit addition.">uip_add32()</a> function.</p>
<h1><a class="anchor" id="memory"></a>
Memory Management</h1>
<p>In the architectures for which uIP is intended, RAM is the most scarce resource. With only a few kilobytes of RAM available for the TCP/IP stack to use, mechanisms used in traditional TCP/IP cannot be directly applied.</p>
<p>The uIP stack does not use explicit dynamic memory allocation. Instead, it uses a single global buffer for holding packets and has a fixed table for holding connection state. The global packet buffer is large enough to contain one packet of maximum size. When a packet arrives from the network, the device driver places it in the global buffer and calls the TCP/IP stack. If the packet contains data, the TCP/IP stack will notify the corresponding application. Because the data in the buffer will be overwritten by the next incoming packet, the application will either have to act immediately on the data or copy the data into a secondary buffer for later processing. The packet buffer will not be overwritten by new packets before the application has processed the data. Packets that arrive when the application is processing the data must be queued, either by the network device or by the device driver. Most single-chip Ethernet controllers have on-chip buffers that are large enough to contain at least 4 maximum sized Ethernet frames. Devices that are handled by the processor, such as RS-232 ports, can copy incoming bytes to a separate buffer during application processing. If the buffers are full, the incoming packet is dropped. This will cause performance degradation, but only when multiple connections are running in parallel. This is because uIP advertises a very small receiver window, which means that only a single TCP segment will be in the network per connection.</p>
<p>In uIP, the same global packet buffer that is used for incoming packets is also used for the TCP/IP headers of outgoing data. If the application sends dynamic data, it may use the parts of the global packet buffer that are not used for headers as a temporary storage buffer. To send the data, the application passes a pointer to the data as well as the length of the data to the stack. The TCP/IP headers are written into the global buffer and once the headers have been produced, the device driver sends the headers and the application data out on the network. The data is not queued for retransmissions. Instead, the application will have to reproduce the data if a retransmission is necessary.</p>
<p>The total amount of memory usage for uIP depends heavily on the applications of the particular device in which the implementations are to be run. The memory configuration determines both the amount of traffic the system should be able to handle and the maximum amount of simultaneous connections. A device that will be sending large e-mails while at the same time running a web server with highly dynamic web pages and multiple simultaneous clients, will require more RAM than a simple Telnet server. It is possible to run the uIP implementation with as little as 200 bytes of RAM, but such a configuration will provide extremely low throughput and will only allow a small number of simultaneous connections.</p>
<h1><a class="anchor" id="api"></a>
Application Program Interface (API)</h1>
<p>The Application Program Interface (API) defines the way the application program interacts with the TCP/IP stack. The most commonly used API for TCP/IP is the BSD socket API which is used in most Unix systems and has heavily influenced the Microsoft Windows WinSock API. Because the socket API uses stop-and-wait semantics, it requires support from an underlying multitasking operating system. Since the overhead of task management, context switching and allocation of stack space for the tasks might be too high in the intended uIP target architectures, the BSD socket interface is not suitable for our purposes.</p>
<p>uIP provides two APIs to programmers: protosockets, a BSD socket-like API without the overhead of full multi-threading, and a "raw" event-based API that is nore low-level than protosockets but uses less memory.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01717.html">Protosockets library</a> </dd>
<dd>
<a class="el" href="a01871.html">Protothreads</a></dd></dl>
<h2><a class="anchor" id="rawapi"></a>
The uIP raw API</h2>
<p>The "raw" uIP API uses an event driven interface where the application is invoked in response to certain events. An application running on top of uIP is implemented as a C function that is called by uIP in response to certain events. uIP calls the application when data is received, when data has been successfully delivered to the other end of the connection, when a new connection has been set up, or when data has to be retransmitted. The application is also periodically polled for new data. The application program provides only one callback function; it is up to the application to deal with mapping different network services to different ports and connections. Because the application is able to act on incoming data and connection requests as soon as the TCP/IP stack receives the packet, low response times can be achieved even in low-end systems.</p>
<p>uIP is different from other TCP/IP stacks in that it requires help from the application when doing retransmissions. Other TCP/IP stacks buffer the transmitted data in memory until the data is known to be successfully delivered to the remote end of the connection. If the data needs to be retransmitted, the stack takes care of the retransmission without notifying the application. With this approach, the data has to be buffered in memory while waiting for an acknowledgment even if the application might be able to quickly regenerate the data if a retransmission has to be made.</p>
<p>In order to reduce memory usage, uIP utilizes the fact that the application may be able to regenerate sent data and lets the application take part in retransmissions. uIP does not keep track of packet contents after they have been sent by the device driver, and uIP requires that the application takes an active part in performing the retransmission. When uIP decides that a segment should be retransmitted, it calls the application with a flag set indicating that a retransmission is required. The application checks the retransmission flag and produces the same data that was previously sent. From the application's standpoint, performing a retransmission is not different from how the data originally was sent. Therefore the application can be written in such a way that the same code is used both for sending data and retransmitting data. Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.</p>
<h3><a class="anchor" id="appevents"></a>
Application Events</h3>
<p>The application must be implemented as a C function, <a class="el" href="a01721.html#ga41aa744caa46913b3b3aedb2a4e78546" title="The name of the application function that uIP should call in response to TCP/IP events.">UIP_APPCALL()</a>, that uIP calls whenever an event occurs. Each event has a corresponding test function that is used to distinguish between different events. The functions are implemented as C macros that will evaluate to either zero or non-zero. Note that certain events can happen in conjunction with each other (i.e., new data can arrive at the same time as data is acknowledged).</p>
<h3><a class="anchor" id="connstate"></a>
The Connection Pointer</h3>
<p>When the application is called by uIP, the global variable <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> is set to point to the <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> structure for the connection that currently is handled, and is called the "current connection". The fields in the <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> structure for the current connection can be used, e.g., to distinguish between different services, or to check to which IP address the connection is connected. One typical use would be to inspect the uip_conn-&gt;lport (the local TCP port number) to decide which service the connection should provide. For instance, an application might decide to act as an HTTP server if the value of uip_conn-&gt;lport is equal to 80 and act as a TELNET server if the value is 23.</p>
<h3><a class="anchor" id="recvdata"></a>
Receiving Data</h3>
<p>If the uIP test function <a class="el" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata()</a> is non-zero, the remote host of the connection has sent new data. The uip_appdata pointer point to the actual data. The size of the data is obtained through the uIP function <a class="el" href="a01726.html#ga1a1bc437c09ddef238abab41d77c3177" title="The length of any incoming data that is currently available (if available) in the uip_appdata buffer...">uip_datalen()</a>. The data is not buffered by uIP, but will be overwritten after the application function returns, and the application will therefor have to either act directly on the incoming data, or by itself copy the incoming data into a buffer for later processing.</p>
<h3><a class="anchor" id="senddata"></a>
Sending Data</h3>
<p>When sending data, uIP adjusts the length of the data sent by the application according to the available buffer space and the current TCP window advertised by the receiver. The amount of buffer space is dictated by the memory configuration. It is therefore possible that all data sent from the application does not arrive at the receiver, and the application may use the <a class="el" href="a01726.html#gab5fecbc62edd128012cea0f47b57ab9f" title="Get the current maximum segment size that can be sent on the current connection.">uip_mss()</a> function to see how much data that actually will be sent by the stack.</p>
<p>The application sends data by using the uIP function <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a>. The <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a> function takes two arguments; a pointer to the data to be sent and the length of the data. If the application needs RAM space for producing the actual data that should be sent, the packet buffer (pointed to by the uip_appdata pointer) can be used for this purpose.</p>
<p>The application can send only one chunk of data at a time on a connection and it is not possible to call <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a> more than once per application invocation; only the data from the last call will be sent.</p>
<h3><a class="anchor" id="rexmitdata"></a>
Retransmitting Data</h3>
<p>Retransmissions are driven by the periodic TCP timer. Every time the periodic timer is invoked, the retransmission timer for each connection is decremented. If the timer reaches zero, a retransmission should be made. As uIP does not keep track of packet contents after they have been sent by the device driver, uIP requires that the application takes an active part in performing the retransmission. When uIP decides that a segment should be retransmitted, the application function is called with the <a class="el" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit()</a> flag set, indicating that a retransmission is required.</p>
<p>The application must check the <a class="el" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit()</a> flag and produce the same data that was previously sent. From the application's standpoint, performing a retransmission is not different from how the data originally was sent. Therefor, the application can be written in such a way that the same code is used both for sending data and retransmitting data. Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.</p>
<h3><a class="anchor" id="closing"></a>
Closing Connections</h3>
<p>The application closes the current connection by calling the <a class="el" href="a01726.html#ga61db1dcb7c760e4dd5d60bf4e5576dca" title="Close the current connection.">uip_close()</a> during an application call. This will cause the connection to be cleanly closed. In order to indicate a fatal error, the application might want to abort the connection and does so by calling the <a class="el" href="a01726.html#ga88d2ccf7cd821f89d9a8df7e3948b56c" title="Abort the current connection.">uip_abort()</a> function.</p>
<p>If the connection has been closed by the remote end, the test function <a class="el" href="a01726.html#gaef6c4140c632b6a406779342cf3b6eb6" title="Has the connection been closed by the other end?">uip_closed()</a> is true. The application may then do any necessary cleanups.</p>
<h3><a class="anchor" id="errors"></a>
Reporting Errors</h3>
<p>There are two fatal errors that can happen to a connection, either that the connection was aborted by the remote host, or that the connection retransmitted the last data too many times and has been aborted. uIP reports this by calling the application function. The application can use the two test functions <a class="el" href="a01726.html#gafbd5fc486dfdf6bf6fc9db52b1f418c4" title="Has the connection been aborted by the other end?">uip_aborted()</a> and <a class="el" href="a01726.html#ga7b2ac4b18bd2ac3912fe67b3b17158c3" title="Has the connection timed out?">uip_timedout()</a> to test for those error conditions.</p>
<h3><a class="anchor" id="polling"></a>
Polling</h3>
<p>When a connection is idle, uIP polls the application every time the periodic timer fires. The application uses the test function <a class="el" href="a01726.html#ga58bb90796c1cdad3aac2ecf44d87b20e" title="Is the connection being polled by uIP?">uip_poll()</a> to check if it is being polled by uIP.</p>
<p>The polling event has two purposes. The first is to let the application periodically know that a connection is idle, which allows the application to close connections that have been idle for too long. The other purpose is to let the application send new data that has been produced. The application can only send data when invoked by uIP, and therefore the poll event is the only way to send data on an otherwise idle connection.</p>
<h3><a class="anchor" id="listen"></a>
Listening Ports</h3>
<p>uIP maintains a list of listening TCP ports. A new port is opened for listening with the <a class="el" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen()</a> function. When a connection request arrives on a listening port, uIP creates a new connection and calls the application function. The test function <a class="el" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected()</a> is true if the application was invoked because a new connection was created.</p>
<p>The application can check the lport field in the <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> structure to check to which port the new connection was connected.</p>
<h3><a class="anchor" id="connect"></a>
Opening Connections</h3>
<p>New connections can be opened from within uIP by the function <a class="el" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect()</a>. This function allocates a new connection and sets a flag in the connection state which will open a TCP connection to the specified IP address and port the next time the connection is polled by uIP. The <a class="el" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect()</a> function returns a pointer to the <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> structure for the new connection. If there are no free connection slots, the function returns NULL.</p>
<p>The function <a class="el" href="a01727.html#ga87f0b54ade0d159fba495089128a4932" title="Construct an IP address from four bytes.">uip_ipaddr()</a> may be used to pack an IP address into the two element 16-bit array used by uIP to represent IP addresses.</p>
<p>Two examples of usage are shown below. The first example shows how to open a connection to TCP port 8080 of the remote end of the current connection. If there are not enough TCP connection slots to allow a new connection to be opened, the <a class="el" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect()</a> function returns NULL and the current connection is aborted by <a class="el" href="a01726.html#ga88d2ccf7cd821f89d9a8df7e3948b56c" title="Abort the current connection.">uip_abort()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_example1_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect</a>(<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a79510aa86d3fa0a0fc6cfc49b1da7279" title="The IP address of the remote host.">ripaddr</a>, HTONS(8080)) == <a class="code" href="a01885.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The null pointer.">NULL</a>) {</div>
<div class="line">      <a class="code" href="a01726.html#ga88d2ccf7cd821f89d9a8df7e3948b56c" title="Abort the current connection.">uip_abort</a>();</div>
<div class="line">   }</div>
<div class="line">}   </div>
</div><!-- fragment --><p>The second example shows how to open a new connection to a specific IP address. No error checks are made in this example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_example2(<span class="keywordtype">void</span>) {</div>
<div class="line">   uip_addr_t ipaddr;</div>
<div class="line"></div>
<div class="line">   <a class="code" href="a01727.html#ga87f0b54ade0d159fba495089128a4932" title="Construct an IP address from four bytes.">uip_ipaddr</a>(ipaddr, 192,168,0,1);</div>
<div class="line">   <a class="code" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect</a>(ipaddr, HTONS(8080));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="examples"></a>
Examples</h1>
<p>This section presents a number of very simple uIP applications. The uIP code distribution contains several more complex applications.</p>
<h2><a class="anchor" id="example1"></a>
A Very Simple Application</h2>
<p>This first example shows a very simple application. The application listens for incoming connections on port 1234. When a connection has been established, the application replies to all data sent to it by saying "ok"</p>
<p>The implementation of this application is shown below. The application is initialized with the function called example1_init() and the uIP callback function is called example1_app(). For this application, the configuration variable UIP_APPCALL should be defined to be example1_app().</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> example1_init(<span class="keywordtype">void</span>) {</div>
<div class="line">   <a class="code" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen</a>(HTONS(1234));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example1_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata</a>() || <a class="code" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit</a>()) {</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;ok\n&quot;</span>, 3);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The initialization function calls the uIP function <a class="el" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen()</a> to register a listening port. The actual application function example1_app() uses the test functions <a class="el" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata()</a> and <a class="el" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit()</a> to determine why it was called. If the application was called because the remote end has sent it data, it responds with an "ok". If the application function was called because data was lost in the network and has to be retransmitted, it also sends an "ok". Note that this example actually shows a complete uIP application. It is not required for an application to deal with all types of events such as <a class="el" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected()</a> or <a class="el" href="a01726.html#ga7b2ac4b18bd2ac3912fe67b3b17158c3" title="Has the connection timed out?">uip_timedout()</a>.</p>
<h2><a class="anchor" id="example2"></a>
A More Advanced Application</h2>
<p>This second example is slightly more advanced than the previous one, and shows how the application state field in the <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> structure is used.</p>
<p>This application is similar to the first application in that it listens to a port for incoming connections and responds to data sent to it with a single "ok". The big difference is that this application prints out a welcoming "Welcome!" message when the connection has been established.</p>
<p>This seemingly small change of operation makes a big difference in how the application is implemented. The reason for the increase in complexity is that if data should be lost in the network, the application must know what data to retransmit. If the "Welcome!" message was lost, the application must retransmit the welcome and if one of the "ok" messages is lost, the application must send a new "ok".</p>
<p>The application knows that as long as the "Welcome!" message has not been acknowledged by the remote host, it might have been dropped in the network. But once the remote host has sent an acknowledgment back, the application can be sure that the welcome has been received and knows that any lost data must be an "ok" message. Thus the application can be in either of two states: either in the WELCOME-SENT state where the "Welcome!" has been sent but not acknowledged, or in the WELCOME-ACKED state where the "Welcome!" has been acknowledged.</p>
<p>When a remote host connects to the application, the application sends the "Welcome!" message and sets it's state to WELCOME-SENT. When the welcome message is acknowledged, the application moves to the WELCOME-ACKED state. If the application receives any new data from the remote host, it responds by sending an "ok" back.</p>
<p>If the application is requested to retransmit the last message, it looks at in which state the application is. If the application is in the WELCOME-SENT state, it sends a "Welcome!" message since it knows that the previous welcome message hasn't been acknowledged. If the application is in the WELCOME-ACKED state, it knows that the last message was an "ok" message and sends such a message.</p>
<p>The implementation of this application is seen below. This configuration settings for the application is follows after its implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>example2_state {</div>
<div class="line">   <span class="keyword">enum</span> {WELCOME_SENT, WELCOME_ACKED} state;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example2_init(<span class="keywordtype">void</span>) {</div>
<div class="line">   <a class="code" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen</a>(HTONS(2345));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example2_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keyword">struct </span>example2_state *s;</div>
<div class="line"></div>
<div class="line">   s = (<span class="keyword">struct </span>example2_state *)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a97f9e1fda815bfb8b1f4577c355ade20" title="The application state.">appstate</a>;</div>
<div class="line">   </div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected</a>()) {</div>
<div class="line">      s-&gt;state = WELCOME_SENT;</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;Welcome!\n&quot;</span>, 9);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">   } </div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gade6634974418e3240c212b9b16864368" title="Has previously sent data been acknowledged?">uip_acked</a>() &amp;&amp; s-&gt;state == WELCOME_SENT) {</div>
<div class="line">      s-&gt;state = WELCOME_ACKED;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata</a>()) {</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;ok\n&quot;</span>, 3);</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit</a>()) {</div>
<div class="line">      <span class="keywordflow">switch</span>(s-&gt;state) {</div>
<div class="line">      <span class="keywordflow">case</span> WELCOME_SENT:</div>
<div class="line">         <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;Welcome!\n&quot;</span>, 9);</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> WELCOME_ACKED:</div>
<div class="line">         <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;ok\n&quot;</span>, 3);</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The configuration for the application:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define UIP_APPCALL       example2_app</span></div>
<div class="line"><span class="preprocessor">#define UIP_APPSTATE_SIZE sizeof(struct example2_state)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="example3"></a>
Differentiating Between Applications</h2>
<p>If the system should run multiple applications, one technique to differentiate between them is to use the TCP port number of either the remote end or the local end of the connection. The example below shows how the two examples above can be combined into one application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> example3_init(<span class="keywordtype">void</span>) {</div>
<div class="line">   example1_init();</div>
<div class="line">   example2_init();   </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example3_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keywordflow">switch</span>(<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5e927bbfba71e139b345839b7e423ea5" title="The local TCP port, in network byte order.">lport</a>) {</div>
<div class="line">   <span class="keywordflow">case</span> HTONS(1234):</div>
<div class="line">      example1_app();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">   <span class="keywordflow">case</span> HTONS(2345):</div>
<div class="line">      example2_app();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="example4"></a>
Utilizing TCP Flow Control</h2>
<p>This example shows a simple application that connects to a host, sends an HTTP request for a file and downloads it to a slow device such a disk drive. This shows how to use the flow control functions of uIP.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> example4_init(<span class="keywordtype">void</span>) {</div>
<div class="line">   uip_ipaddr_t ipaddr;</div>
<div class="line">   <a class="code" href="a01727.html#ga87f0b54ade0d159fba495089128a4932" title="Construct an IP address from four bytes.">uip_ipaddr</a>(ipaddr, 192,168,0,1);</div>
<div class="line">   <a class="code" href="a01726.html#gadd213d8b34d70919ccac28303219cb82" title="Connect to a remote host using TCP.">uip_connect</a>(ipaddr, HTONS(80));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example4_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected</a>() || <a class="code" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit</a>()) {</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(<span class="stringliteral">&quot;GET /file HTTP/1.0\r\nServer:192.186.0.1\r\n\r\n&quot;</span>,</div>
<div class="line">               48);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata</a>()) {</div>
<div class="line">      device_enqueue(<a class="code" href="a01866.html#gad5848369ab5b02f2fb02d8390ccbaf79" title="Pointer to the application data in the packet buffer.">uip_appdata</a>, <a class="code" href="a01726.html#ga1a1bc437c09ddef238abab41d77c3177" title="The length of any incoming data that is currently available (if available) in the uip_appdata buffer...">uip_datalen</a>());</div>
<div class="line">      <span class="keywordflow">if</span>(device_queue_full()) {</div>
<div class="line">         <a class="code" href="a01726.html#ga0a8bb9d6d0f1f56852ccfccbbad6c5d8" title="Tell the sending host to stop sending data.">uip_stop</a>();</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga58bb90796c1cdad3aac2ecf44d87b20e" title="Is the connection being polled by uIP?">uip_poll</a>() &amp;&amp; <a class="code" href="a01726.html#ga64a238a5c02640a7a4aef004163aeb47" title="Find out if the current connection has been previously stopped with uip_stop().">uip_stopped</a>()) {</div>
<div class="line">      <span class="keywordflow">if</span>(!device_queue_full()) {</div>
<div class="line">         <a class="code" href="a01726.html#ga81ac47cee1c18f6aa479044069db7ca3" title="Restart the current connection, if is has previously been stopped with uip_stop().">uip_restart</a>();</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the connection has been established, an HTTP request is sent to the server. Since this is the only data that is sent, the application knows that if it needs to retransmit any data, it is that request that should be retransmitted. It is therefore possible to combine these two events as is done in the example.</p>
<p>When the application receives new data from the remote host, it sends this data to the device by using the function device_enqueue(). It is important to note that this example assumes that this function copies the data into its own buffers. The data in the uip_appdata buffer will be overwritten by the next incoming packet.</p>
<p>If the device's queue is full, the application stops the data from the remote host by calling the uIP function <a class="el" href="a01726.html#ga0a8bb9d6d0f1f56852ccfccbbad6c5d8" title="Tell the sending host to stop sending data.">uip_stop()</a>. The application can then be sure that it will not receive any new data until <a class="el" href="a01726.html#ga81ac47cee1c18f6aa479044069db7ca3" title="Restart the current connection, if is has previously been stopped with uip_stop().">uip_restart()</a> is called. The application polling event is used to check if the device's queue is no longer full and if so, the data flow is restarted with <a class="el" href="a01726.html#ga81ac47cee1c18f6aa479044069db7ca3" title="Restart the current connection, if is has previously been stopped with uip_stop().">uip_restart()</a>.</p>
<h2><a class="anchor" id="example5"></a>
A Simple Web Server</h2>
<p>This example shows a very simple file server application that listens to two ports and uses the port number to determine which file to send. If the files are properly formatted, this simple application can be used as a web server with static pages. The implementation follows.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>example5_state {</div>
<div class="line">   <span class="keywordtype">char</span> *dataptr;</div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataleft;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example5_init(<span class="keywordtype">void</span>) {</div>
<div class="line">   <a class="code" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen</a>(HTONS(80));</div>
<div class="line">   <a class="code" href="a01726.html#ga50ff1ab4c8327f775eee393262ef1811" title="Start listening to the specified port.">uip_listen</a>(HTONS(81));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> example5_app(<span class="keywordtype">void</span>) {</div>
<div class="line">   <span class="keyword">struct </span>example5_state *s;</div>
<div class="line">   s = (<span class="keyword">struct </span>example5_state)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;appstate;</div>
<div class="line">   </div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected</a>()) {</div>
<div class="line">      <span class="keywordflow">switch</span>(<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5e927bbfba71e139b345839b7e423ea5" title="The local TCP port, in network byte order.">lport</a>) {</div>
<div class="line">      <span class="keywordflow">case</span> HTONS(80):</div>
<div class="line">         s-&gt;dataptr = data_port_80;</div>
<div class="line">         s-&gt;dataleft = datalen_port_80;</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> HTONS(81):</div>
<div class="line">         s-&gt;dataptr = data_port_81;</div>
<div class="line">         s-&gt;dataleft = datalen_port_81;</div>
<div class="line">         <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(s-&gt;dataptr, s-&gt;dataleft);</div>
<div class="line">      <span class="keywordflow">return</span>;      </div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gade6634974418e3240c212b9b16864368" title="Has previously sent data been acknowledged?">uip_acked</a>()) {</div>
<div class="line">      <span class="keywordflow">if</span>(s-&gt;dataleft &lt; <a class="code" href="a01726.html#gab5fecbc62edd128012cea0f47b57ab9f" title="Get the current maximum segment size that can be sent on the current connection.">uip_mss</a>()) {</div>
<div class="line">         <a class="code" href="a01726.html#ga61db1dcb7c760e4dd5d60bf4e5576dca" title="Close the current connection.">uip_close</a>();</div>
<div class="line">         <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      s-&gt;dataptr += <a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5c55920c6901817dce661762e785614e" title="Length of the data that was previously sent.">len</a>;</div>
<div class="line">      s-&gt;dataleft -= <a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5c55920c6901817dce661762e785614e" title="Length of the data that was previously sent.">len</a>;</div>
<div class="line">      <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(s-&gt;dataptr, s-&gt;dataleft);      </div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The application state consists of a pointer to the data that should be sent and the size of the data that is left to send. When a remote host connects to the application, the local port number is used to determine which file to send. The first chunk of data is sent using <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a>. uIP makes sure that no more than MSS bytes of data is actually sent, even though s-&gt;dataleft may be larger than the MSS.</p>
<p>The application is driven by incoming acknowledgments. When data has been acknowledged, new data can be sent. If there is no more data to send, the connection is closed using <a class="el" href="a01726.html#ga61db1dcb7c760e4dd5d60bf4e5576dca" title="Close the current connection.">uip_close()</a>.</p>
<h2><a class="anchor" id="example6"></a>
Structured Application Program Design</h2>
<p>When writing larger programs using uIP it is useful to be able to utilize the uIP API in a structured way. The following example provides a structured design that has showed itself to be useful for writing larger protocol implementations than the previous examples showed here. The program is divided into an uIP event handler function that calls seven application handler functions that process new data, act on acknowledged data, send new data, deal with connection establishment or closure events and handle errors. The functions are called newdata(), acked(), senddata(), connected(), closed(), aborted(), and timedout(), and needs to be written specifically for the protocol that is being implemented.</p>
<p>The uIP event handler function is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> example6_app(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gafbd5fc486dfdf6bf6fc9db52b1f418c4" title="Has the connection been aborted by the other end?">uip_aborted</a>()) {</div>
<div class="line">    aborted();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga7b2ac4b18bd2ac3912fe67b3b17158c3" title="Has the connection timed out?">uip_timedout</a>()) {</div>
<div class="line">    timedout();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gaef6c4140c632b6a406779342cf3b6eb6" title="Has the connection been closed by the other end?">uip_closed</a>()) {</div>
<div class="line">    closed();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected</a>()) {</div>
<div class="line">    connected();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gade6634974418e3240c212b9b16864368" title="Has previously sent data been acknowledged?">uip_acked</a>()) {</div>
<div class="line">    acked();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata</a>()) {</div>
<div class="line">    newdata();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code" href="a01726.html#gaa8933ad15a2e2947dae4a5cff50e6007" title="Do we need to retransmit previously data?">uip_rexmit</a>() ||</div>
<div class="line">     <a class="code" href="a01726.html#ga26a14b8dae3f861830af9e7cf1e03725" title="Is new incoming data available?">uip_newdata</a>() ||</div>
<div class="line">     <a class="code" href="a01726.html#gade6634974418e3240c212b9b16864368" title="Has previously sent data been acknowledged?">uip_acked</a>() ||</div>
<div class="line">     <a class="code" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected</a>() ||</div>
<div class="line">     <a class="code" href="a01726.html#ga58bb90796c1cdad3aac2ecf44d87b20e" title="Is the connection being polled by uIP?">uip_poll</a>()) {</div>
<div class="line">    senddata();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The function starts with dealing with any error conditions that might have happened by checking if <a class="el" href="a01726.html#gafbd5fc486dfdf6bf6fc9db52b1f418c4" title="Has the connection been aborted by the other end?">uip_aborted()</a> or <a class="el" href="a01726.html#ga7b2ac4b18bd2ac3912fe67b3b17158c3" title="Has the connection timed out?">uip_timedout()</a> are true. If so, the appropriate error function is called. Also, if the connection has been closed, the closed() function is called to the it deal with the event.</p>
<p>Next, the function checks if the connection has just been established by checking if <a class="el" href="a01726.html#gadb971fb1525d0c5002f52125b05f3218" title="Has the connection just been connected?">uip_connected()</a> is true. The connected() function is called and is supposed to do whatever needs to be done when the connection is established, such as intializing the application state for the connection. Since it may be the case that data should be sent out, the senddata() function is called to deal with the outgoing data.</p>
<p>The following very simple application serves as an example of how the application handler functions might look. This application simply waits for any data to arrive on the connection, and responds to the data by sending out the message "Hello world!". To illustrate how to develop an application state machine, this message is sent in two parts, first the "Hello" part and then the "world!" part.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define STATE_WAITING 0</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define STATE_HELLO   1</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define STATE_WORLD   2</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">struct </span>example6_state {</div>
<div class="line">  uint8_t state;</div>
<div class="line">  <span class="keywordtype">char</span> *textptr;</div>
<div class="line">  <span class="keywordtype">int</span>  textlen;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> aborted(<span class="keywordtype">void</span>) {}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> timedout(<span class="keywordtype">void</span>) {}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> closed(<span class="keywordtype">void</span>) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> connected(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a97f9e1fda815bfb8b1f4577c355ade20" title="The application state.">appstate</a>;</div>
<div class="line"></div>
<div class="line">  s-&gt;state   = STATE_WAITING;</div>
<div class="line">  s-&gt;textlen = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> newdata(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a97f9e1fda815bfb8b1f4577c355ade20" title="The application state.">appstate</a>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>(s-&gt;state == STATE_WAITING) {</div>
<div class="line">    s-&gt;state   = STATE_HELLO;</div>
<div class="line">    s-&gt;textptr = <span class="stringliteral">&quot;Hello &quot;</span>;</div>
<div class="line">    s-&gt;textlen = 6;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> acked(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a97f9e1fda815bfb8b1f4577c355ade20" title="The application state.">appstate</a>;</div>
<div class="line">  </div>
<div class="line">  s-&gt;textlen -= <a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5c55920c6901817dce661762e785614e" title="Length of the data that was previously sent.">len</a>;</div>
<div class="line">  s-&gt;textptr += <a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a5c55920c6901817dce661762e785614e" title="Length of the data that was previously sent.">len</a>;</div>
<div class="line">  <span class="keywordflow">if</span>(s-&gt;textlen == 0) {</div>
<div class="line">    <span class="keywordflow">switch</span>(s-&gt;state) {</div>
<div class="line">    <span class="keywordflow">case</span> STATE_HELLO:</div>
<div class="line">      s-&gt;state   = STATE_WORLD;</div>
<div class="line">      s-&gt;textptr = <span class="stringliteral">&quot;world!\n&quot;</span>;</div>
<div class="line">      s-&gt;textlen = 7;</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> STATE_WORLD:</div>
<div class="line">      <a class="code" href="a01726.html#ga61db1dcb7c760e4dd5d60bf4e5576dca" title="Close the current connection.">uip_close</a>();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> senddata(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keyword">struct </span>example6_state *s = (<span class="keyword">struct </span>example6_state *)<a class="code" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a>-&gt;<a class="code" href="a00108.html#a97f9e1fda815bfb8b1f4577c355ade20" title="The application state.">appstate</a>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>(s-&gt;textlen &gt; 0) {</div>
<div class="line">    <a class="code" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send</a>(s-&gt;textptr, s-&gt;textlen);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The application state consists of a "state" variable, a "textptr" pointer to a text message and the "textlen" length of the text message. The "state" variable can be either "STATE_WAITING", meaning that the application is waiting for data to arrive from the network, "STATE_HELLO", in which the application is sending the "Hello" part of the message, or "STATE_WORLD", in which the application is sending the "world!" message.</p>
<p>The application does not handle errors or connection closing events, and therefore the aborted(), timedout() and closed() functions are implemented as empty functions.</p>
<p>The connected() function will be called when a connection has been established, and in this case sets the "state" variable to be "STATE_WAITING" and the "textlen" variable to be zero, indicating that there is no message to be sent out.</p>
<p>When new data arrives from the network, the newdata() function will be called by the event handler function. The newdata() function will check if the connection is in the "STATE_WAITING" state, and if so switches to the "STATE_HELLO" state and registers a 6 byte long "Hello
" message with the connection. This message will later be sent out by the senddata() function.</p>
<p>The acked() function is called whenever data that previously was sent has been acknowleged by the receiving host. This acked() function first reduces the amount of data that is left to send, by subtracting the length of the previously sent data (obtained from "uip_conn-&gt;len") from the "textlen" variable, and also adjusts the "textptr" pointer accordingly. It then checks if the "textlen" variable now is zero, which indicates that all data now has been successfully received, and if so changes application state. If the application was in the "STATE_HELLO" state, it switches state to "STATE_WORLD" and sets up a 7 byte "world!\n" message to be sent. If the application was in the "STATE_WORLD" state, it closes the connection.</p>
<p>Finally, the senddata() function takes care of actually sending the data that is to be sent. It is called by the event handler function when new data has been received, when data has been acknowledged, when a new connection has been established, when the connection is polled because of inactivity, or when a retransmission should be made. The purpose of the senddata() function is to optionally format the data that is to be sent, and to call the <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a> function to actually send out the data. In this particular example, the function simply calls <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a> with the appropriate arguments if data is to be sent, after checking if data should be sent out or not as indicated by the "textlen" variable.</p>
<p>It is important to note that the senddata() function never should affect the application state; this should only be done in the acked() and newdata() functions.</p>
<h1><a class="anchor" id="protoimpl"></a>
Protocol Implementations</h1>
<p>The protocols in the TCP/IP protocol suite are designed in a layered fashion where each protocol performs a specific function and the interactions between the protocol layers are strictly defined. While the layered approach is a good way to design protocols, it is not always the best way to implement them. In uIP, the protocol implementations are tightly coupled in order to save code space.</p>
<p>This section gives detailed information on the specific protocol implementations in uIP.</p>
<h2><a class="anchor" id="ip"></a>
IP --- Internet Protocol</h2>
<p>When incoming packets are processed by uIP, the IP layer is the first protocol that examines the packet. The IP layer does a few simple checks such as if the destination IP address of the incoming packet matches any of the local IP address and verifies the IP header checksum. Since there are no IP options that are strictly required and because they are very uncommon, any IP options in received packets are dropped.</p>
<h3><a class="anchor" id="ipreass"></a>
IP Fragment Reassembly</h3>
<p>IP fragment reassembly is implemented using a separate buffer that holds the packet to be reassembled. An incoming fragment is copied into the right place in the buffer and a bit map is used to keep track of which fragments have been received. Because the first byte of an IP fragment is aligned on an 8-byte boundary, the bit map requires a small amount of memory. When all fragments have been reassembled, the resulting IP packet is passed to the transport layer. If all fragments have not been received within a specified time frame, the packet is dropped.</p>
<p>The current implementation only has a single buffer for holding packets to be reassembled, and therefore does not support simultaneous reassembly of more than one packet. Since fragmented packets are uncommon, this ought to be a reasonable decision. Extending the implementation to support multiple buffers would be straightforward, however.</p>
<h3><a class="anchor" id="ipbroadcast"></a>
Broadcasts and Multicasts</h3>
<p>IP has the ability to broadcast and multicast packets on the local network. Such packets are addressed to special broadcast and multicast addresses. Broadcast is used heavily in many UDP based protocols such as the Microsoft Windows file-sharing SMB protocol. Multicast is primarily used in protocols used for multimedia distribution such as RTP. TCP is a point-to-point protocol and does not use broadcast or multicast packets. uIP current supports broadcast packets as well as sending multicast packets. Joining multicast groups (IGMP) and receiving non-local multicast packets is not currently supported.</p>
<h2><a class="anchor" id="icmp"></a>
ICMP --- Internet Control Message Protocol</h2>
<p>The ICMP protocol is used for reporting soft error conditions and for querying host parameters. Its main use is, however, the echo mechanism which is used by the "ping" program.</p>
<p>The ICMP implementation in uIP is very simple as itis restricted to only implement ICMP echo messages. Replies to echo messages are constructed by simply swapping the source and destination IP addresses of incoming echo requests and rewriting the ICMP header with the Echo-Reply message type. The ICMP checksum is adjusted using standard techniques (see RFC1624).</p>
<p>Since only the ICMP echo message is implemented, there is no support for Path MTU discovery or ICMP redirect messages. Neither of these is strictly required for interoperability; they are performance enhancement mechanisms.</p>
<h2><a class="anchor" id="tcp"></a>
TCP --- Transmission Control Protocol</h2>
<p>The TCP implementation in uIP is driven by incoming packets and timer events. Incoming packets are parsed by TCP and if the packet contains data that is to be delivered to the application, the application is invoked by the means of the application function call. If the incoming packet acknowledges previously sent data, the connection state is updated and the application is informed, allowing it to send out new data.</p>
<h3><a class="anchor" id="listeb"></a>
Listening Connections</h3>
<p>TCP allows a connection to listen for incoming connection requests. In uIP, a listening connection is identified by the 16-bit port number and incoming connection requests are checked against the list of listening connections. This list of listening connections is dynamic and can be altered by the applications in the system.</p>
<h3><a class="anchor" id="slidingwindow"></a>
Sliding Window</h3>
<p>Most TCP implementations use a sliding window mechanism for sending data. Multiple data segments are sent in succession without waiting for an acknowledgment for each segment.</p>
<p>The sliding window algorithm uses a lot of 32-bit operations and because 32-bit arithmetic is fairly expensive on most 8-bit CPUs, uIP does not implement it. Also, uIP does not buffer sent packets and a sliding window implementation that does not buffer sent packets will have to be supported by a complex application layer. Instead, uIP allows only a single TCP segment per connection to be unacknowledged at any given time.</p>
<p>It is important to note that even though most TCP implementations use the sliding window algorithm, it is not required by the TCP specifications. Removing the sliding window mechanism does not affect interoperability in any way.</p>
<h3><a class="anchor" id="rttest"></a>
Round-Trip Time Estimation</h3>
<p>TCP continuously estimates the current Round-Trip Time (RTT) of every active connection in order to find a suitable value for the retransmission time-out.</p>
<p>The RTT estimation in uIP is implemented using TCP's periodic timer. Each time the periodic timer fires, it increments a counter for each connection that has unacknowledged data in the network. When an acknowledgment is received, the current value of the counter is used as a sample of the RTT. The sample is used together with Van Jacobson's standard TCP RTT estimation function to calculate an estimate of the RTT. Karn's algorithm is used to ensure that retransmissions do not skew the estimates.</p>
<h3><a class="anchor" id="rexmit"></a>
Retransmissions</h3>
<p>Retransmissions are driven by the periodic TCP timer. Every time the periodic timer is invoked, the retransmission timer for each connection is decremented. If the timer reaches zero, a retransmission should be made.</p>
<p>As uIP does not keep track of packet contents after they have been sent by the device driver, uIP requires that the application takes an active part in performing the retransmission. When uIP decides that a segment should be retransmitted, it calls the application with a flag set indicating that a retransmission is required. The application checks the retransmission flag and produces the same data that was previously sent. From the application's standpoint, performing a retransmission is not different from how the data originally was sent. Therefore the application can be written in such a way that the same code is used both for sending data and retransmitting data. Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.</p>
<h3><a class="anchor" id="flowcontrol"></a>
Flow Control</h3>
<p>The purpose of TCP's flow control mechanisms is to allow communication between hosts with wildly varying memory dimensions. In each TCP segment, the sender of the segment indicates its available buffer space. A TCP sender must not send more data than the buffer space indicated by the receiver.</p>
<p>In uIP, the application cannot send more data than the receiving host can buffer. And application cannot send more data than the amount of bytes it is allowed to send by the receiving host. If the remote host cannot accept any data at all, the stack initiates the zero window probing mechanism.</p>
<h3><a class="anchor" id="congestioncontrol"></a>
Congestion Control</h3>
<p>The congestion control mechanisms limit the number of simultaneous TCP segments in the network. The algorithms used for congestion control are designed to be simple to implement and require only a few lines of code.</p>
<p>Since uIP only handles one in-flight TCP segment per connection, the amount of simultaneous segments cannot be further limited, thus the congestion control mechanisms are not needed.</p>
<h3><a class="anchor" id="urgdata"></a>
Urgent Data</h3>
<p>TCP's urgent data mechanism provides an application-to-application notification mechanism, which can be used by an application to mark parts of the data stream as being more urgent than the normal stream. It is up to the receiving application to interpret the meaning of the urgent data.</p>
<p>In many TCP implementations, including the BSD implementation, the urgent data feature increases the complexity of the implementation because it requires an asynchronous notification mechanism in an otherwise synchronous API. As uIP already use an asynchronous event based API, the implementation of the urgent data feature does not lead to increased complexity.</p>
<h1><a class="anchor" id="performance"></a>
Performance</h1>
<p>In TCP/IP implementations for high-end systems, processing time is dominated by the checksum calculation loop, the operation of copying packet data and context switching. Operating systems for high-end systems often have multiple protection domains for protecting kernel data from user processes and user processes from each other. Because the TCP/IP stack is run in the kernel, data has to be copied between the kernel space and the address space of the user processes and a context switch has to be performed once the data has been copied. Performance can be enhanced by combining the copy operation with the checksum calculation. Because high-end systems usually have numerous active connections, packet demultiplexing is also an expensive operation.</p>
<p>A small embedded device does not have the necessary processing power to have multiple protection domains and the power to run a multitasking operating system. Therefore there is no need to copy data between the TCP/IP stack and the application program. With an event based API there is no context switch between the TCP/IP stack and the applications.</p>
<p>In such limited systems, the TCP/IP processing overhead is dominated by the copying of packet data from the network device to host memory, and checksum calculation. Apart from the checksum calculation and copying, the TCP processing done for an incoming packet involves only updating a few counters and flags before handing the data over to the application. Thus an estimate of the CPU overhead of our TCP/IP implementations can be obtained by calculating the amount of CPU cycles needed for the checksum calculation and copying of a maximum sized packet.</p>
<h2><a class="anchor" id="delack"></a>
The Impact of Delayed Acknowledgments</h2>
<p>Most TCP receivers implement the delayed acknowledgment algorithm for reducing the number of pure acknowledgment packets sent. A TCP receiver using this algorithm will only send acknowledgments for every other received segment. If no segment is received within a specific time-frame, an acknowledgment is sent. The time-frame can be as high as 500 ms but typically is 200 ms.</p>
<p>A TCP sender such as uIP that only handles a single outstanding TCP segment will interact poorly with the delayed acknowledgment algorithm. Because the receiver only receives a single segment at a time, it will wait as much as 500 ms before an acknowledgment is sent. This means that the maximum possible throughput is severely limited by the 500 ms idle time.</p>
<p>Thus the maximum throughput equation when sending data from uIP will be $p = s / (t + t_d)$ where $s$ is the segment size and $t_d$ is the delayed acknowledgment timeout, which typically is between 200 and 500 ms. With a segment size of 1000 bytes, a round-trip time of 40 ms and a delayed acknowledgment timeout of 200 ms, the maximum throughput will be 4166 bytes per second. With the delayed acknowledgment algorithm disabled at the receiver, the maximum throughput would be 25000 bytes per second.</p>
<p>It should be noted, however, that since small systems running uIP are not very likely to have large amounts of data to send, the delayed acknowledgmen t throughput degradation of uIP need not be very severe. Small amounts of data sent by such a system will not span more than a single TCP segment, and would therefore not be affected by the throughput degradation anyway.</p>
<p>The maximum throughput when uIP acts as a receiver is not affected by the delayed acknowledgment throughput degradation.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="a01722.html">uIP TCP throughput booster hack</a> module implements a hack that overcomes the problems with the delayed acknowledgment throughput degradation. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae0825474feee11b4e038bfe71757875f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIP_APPDATA_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer size available for user data in the uip_buf buffer. </p>
<p>This macro holds the available size for user data in the uip_buf buffer. The macro is intended to be used for checking bounds of available user data.</p>
<p>Example: </p>
<div class="fragment"><div class="line">snprintf(<a class="code" href="a01866.html#gad5848369ab5b02f2fb02d8390ccbaf79" title="Pointer to the application data in the packet buffer.">uip_appdata</a>, <a class="code" href="a01866.html#gae0825474feee11b4e038bfe71757875f" title="The buffer size available for user data in the uip_buf buffer.">UIP_APPDATA_SIZE</a>, <span class="stringliteral">&quot;%u\n&quot;</span>, i);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="a00285_source.html#l01872">1872</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae63bbcf2f409069439613cd288355dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIP_EXT_HDR_BITMAP_HBHO&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitmaps for extension header processing. </p>
<p>When processing extension headers, we should record somehow which one we see, because you cannot have twice the same header, except for destination We store all this in one uint8_t bitmap one bit for each header expected. The order in the bitmap is the order recommended in RFC2460 </p>

<p>Definition at line <a class="el" href="a00285_source.html#l01908">1908</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

<p>Referenced by <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<a class="anchor" id="ga936d474f1896bf364c717eb536ecf0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uip_is_addr_link_local</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((((a)-&gt;u8[0]) == 0xFE) &amp;&amp; \</div>
<div class="line">  (((a)-&gt;u8[1]) == 0x80))</div>
</div><!-- fragment -->
<p>is addr (a) a link local unicast address, see RFC3513 i.e. </p>
<p>is (a) on prefix FE80::/10 a is of type uip_ipaddr_t* </p>

<p>Definition at line <a class="el" href="a00285_source.html#l02056">2056</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

<p>Referenced by <a class="el" href="a00306_source.html#l01094">roll_tm_icmp_input()</a>, <a class="el" href="a00322_source.html#l00496">uip_ds6_select_src()</a>, <a class="el" href="a00326_source.html#l00768">uip_nd6_ra_input()</a>, and <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<a class="anchor" id="gaab8b0e871e3e46072cf7672778972521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uip_is_addr_linklocal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((a)-&gt;u8[0] == 0xfe &amp;&amp;                         \</div>
<div class="line">   (a)-&gt;u8[1] == 0x80)</div>
</div><!-- fragment -->
<p>Checks whether the address a is link local. </p>
<p>a is of type uip_ipaddr_t </p>

<p>Definition at line <a class="el" href="a00285_source.html#l02000">2000</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5dafb9c2d4f98a72346c5c3e18dd3559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uip_is_addr_mcast_non_routable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((((a)-&gt;u8[0]) == 0xFF) &amp;&amp; \</div>
<div class="line">   (((a)-&gt;u8[1] &amp; 0x0F) &lt;= 0x02))</div>
</div><!-- fragment -->
<p>is address a non-routable multicast address. </p>
<p>Scopes 1 (interface-local) and 2 (link-local) are non-routable See RFC4291 and draft-ietf-6man-multicast-scopes a is of type uip_ip6addr_t* </p>

<p>Definition at line <a class="el" href="a00285_source.html#l02110">2110</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga410e205fa84ee79b9c17c7ab112d71f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uip_is_addr_mcast_routable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((((a)-&gt;u8[0]) == 0xFF) &amp;&amp; \</div>
<div class="line">   (((a)-&gt;u8[1] &amp; 0x0F) &gt; 0x02))</div>
</div><!-- fragment -->
<p>is address a routable multicast address. </p>
<p>Scope 3 (Realm-Local) or higher are routable Realm-Local scope is defined in draft-ietf-6man-multicast-scopes See RFC4291 and draft-ietf-6man-multicast-scopes a is of type uip_ip6addr_t* </p>

<p>Definition at line <a class="el" href="a00285_source.html#l02121">2121</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

<p>Referenced by <a class="el" href="a00322_source.html#l00496">uip_ds6_select_src()</a>, and <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<a class="anchor" id="ga488258fa3fa2856c84a9884842423086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uip_l2_l3_hdr_len&#160;&#160;&#160;(<a class="el" href="a01732.html#gae6f4a2453dbd8bc60e6a82774552366a">UIP_LLH_LEN</a> + UIP_IPH_LEN + <a class="el" href="a01876.html#ga0c63b80e0f8038403df5fee2bac3aab8">uip_ext_len</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sums below are quite used in ND. </p>
<p>When used for uip_buf, we include link layer length when used for uip_len, we do not, hence we need values with and without LLH_LEN we do not use capital letters as these values are variable </p>

<p>Definition at line <a class="el" href="a00285_source.html#l00086">86</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c0814ed491fa452ec97910c0728d410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIP_STAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The uIP TCP/IP statistics. </p>
<p>This is the variable in which the uIP TCP/IP statistics are gathered. </p>

<p>Definition at line <a class="el" href="a00285_source.html#l01429">1429</a> of file <a class="el" href="a00285_source.html">uip.h</a>.</p>

<p>Referenced by <a class="el" href="a00324_source.html#l00080">uip_icmp6_echo_request_input()</a>, <a class="el" href="a00324_source.html#l00167">uip_icmp6_error_output()</a>, <a class="el" href="a00326_source.html#l00396">uip_nd6_na_input()</a>, <a class="el" href="a00326_source.html#l00147">uip_nd6_ns_input()</a>, <a class="el" href="a00326_source.html#l00330">uip_nd6_ns_output()</a>, <a class="el" href="a00326_source.html#l00768">uip_nd6_ra_input()</a>, <a class="el" href="a00326_source.html#l00728">uip_nd6_rs_output()</a>, and <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9287706e35d5fb2080d1f6f14551f76f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uip_chksum </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the Internet checksum over a buffer. </p>
<p>The Internet checksum is the one's complement of the one's complement sum of all 16-bit words in the buffer.</p>
<p>See RFC1071.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to the buffer over which the checksum is to be computed.</td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer over which the checksum is to be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Internet checksum of the buffer. </dd></dl>

<p>Definition at line <a class="el" href="a00328_source.html#l00335">335</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ec91f3c5d75781b5ad9915828aaeba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uip_icmp6chksum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the ICMP checksum of the packet in uip_buf. </p>
<dl class="section return"><dt>Returns</dt><dd>The ICMP checksum of the ICMP packet in uip_buf </dd></dl>

<p>Definition at line <a class="el" href="a00328_source.html#l00386">386</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

<p>Referenced by <a class="el" href="a01332_source.html#l00603">mac_translateIcmpLinkLayer()</a>, <a class="el" href="a00324_source.html#l00080">uip_icmp6_echo_request_input()</a>, <a class="el" href="a00324_source.html#l00167">uip_icmp6_error_output()</a>, <a class="el" href="a00324_source.html#l00254">uip_icmp6_send()</a>, <a class="el" href="a00326_source.html#l00147">uip_nd6_ns_input()</a>, <a class="el" href="a00326_source.html#l00330">uip_nd6_ns_output()</a>, <a class="el" href="a00326_source.html#l00728">uip_nd6_rs_output()</a>, and <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<a class="anchor" id="ga707e869bd80c32239d214a8ebe560c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uip_ipchksum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the IP header checksum of the packet header in uip_buf. </p>
<p>The IP header checksum is the Internet checksum of the 20 bytes of the IP header.</p>
<dl class="section return"><dt>Returns</dt><dd>The IP header checksum of the IP header in the uip_buf buffer. </dd></dl>

<p>Definition at line <a class="el" href="a00328_source.html#l00342">342</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

<p>Referenced by <a class="el" href="a00281_source.html#l00054">uip_split_output()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c90e268d83fc6cd9cd78bfa435b8140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uip_process </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process the options within a hop by hop or destination option header </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0,:</td><td>nothing to send, </td></tr>
    <tr><td class="paramname">1,:</td><td>drop pkt </td></tr>
    <tr><td class="paramname">2,:</td><td>ICMP error message to send </td></tr>
  </table>
  </dd>
</dl>
<p>Call echo reply input function. </p>

<p>Definition at line <a class="el" href="a00328_source.html#l00918">918</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

<p>References <a class="el" href="a00325_source.html#l00054">ICMP6_DST_UNREACH</a>, <a class="el" href="a00325_source.html#l00083">ICMP6_DST_UNREACH_NOPORT</a>, <a class="el" href="a00325_source.html#l00080">ICMP6_DST_UNREACH_NOTNEIGHBOR</a>, <a class="el" href="a00325_source.html#l00059">ICMP6_ECHO_REPLY</a>, <a class="el" href="a00325_source.html#l00058">ICMP6_ECHO_REQUEST</a>, <a class="el" href="a00325_source.html#l00064">ICMP6_NA</a>, <a class="el" href="a00325_source.html#l00063">ICMP6_NS</a>, <a class="el" href="a00325_source.html#l00055">ICMP6_PACKET_TOO_BIG</a>, <a class="el" href="a00325_source.html#l00057">ICMP6_PARAM_PROB</a>, <a class="el" href="a00325_source.html#l00094">ICMP6_PARAMPROB_HEADER</a>, <a class="el" href="a00325_source.html#l00095">ICMP6_PARAMPROB_NEXTHEADER</a>, <a class="el" href="a00325_source.html#l00062">ICMP6_RA</a>, <a class="el" href="a00325_source.html#l00072">ICMP6_ROLL_TM</a>, <a class="el" href="a00325_source.html#l00067">ICMP6_RPL</a>, <a class="el" href="a00325_source.html#l00061">ICMP6_RS</a>, <a class="el" href="a00325_source.html#l00088">ICMP6_TIME_EXCEED_TRANSIT</a>, <a class="el" href="a00325_source.html#l00056">ICMP6_TIME_EXCEEDED</a>, <a class="el" href="a00285_source.html#l01348">uip_conn::initialmss</a>, <a class="el" href="a00285_source.html#l01345">uip_conn::len</a>, <a class="el" href="a00285_source.html#l01337">uip_conn::lport</a>, <a class="el" href="a00285_source.html#l01394">uip_udp_conn::lport</a>, <a class="el" href="a00285_source.html#l01346">uip_conn::mss</a>, <a class="el" href="a00285_source.html#l01357">uip_conn::nrtx</a>, <a class="el" href="a01200_source.html#l00186">NULL</a>, <a class="el" href="a00285_source.html#l01341">uip_conn::rcv_nxt</a>, <a class="el" href="a00285_source.html#l01335">uip_conn::ripaddr</a>, <a class="el" href="a00285_source.html#l01393">uip_udp_conn::ripaddr</a>, <a class="el" href="a00306_source.html#l01094">roll_tm_icmp_input()</a>, <a class="el" href="a00285_source.html#l01338">uip_conn::rport</a>, <a class="el" href="a00285_source.html#l01395">uip_udp_conn::rport</a>, <a class="el" href="a00285_source.html#l01354">uip_conn::rto</a>, <a class="el" href="a00285_source.html#l01350">uip_conn::sa</a>, <a class="el" href="a00285_source.html#l01343">uip_conn::snd_nxt</a>, <a class="el" href="a00285_source.html#l01352">uip_conn::sv</a>, <a class="el" href="a00285_source.html#l01355">uip_conn::tcpstateflags</a>, <a class="el" href="a00285_source.html#l01356">uip_conn::timer</a>, <a class="el" href="a00285_source.html#l01396">uip_udp_conn::ttl</a>, <a class="el" href="a00520_source.html#l00045">uip_add32()</a>, <a class="el" href="a00272_source.html#l00078">UIP_APPCALL</a>, <a class="el" href="a00328_source.html#l00173">uip_appdata</a>, <a class="el" href="a00328_source.html#l00196">uip_conn</a>, <a class="el" href="a00289_source.html#l00419">UIP_CONNS</a>, <a class="el" href="a00323_source.html#l00348">uip_ds6_is_my_addr</a>, <a class="el" href="a00323_source.html#l00350">uip_ds6_is_my_maddr</a>, <a class="el" href="a00322_source.html#l00496">uip_ds6_select_src()</a>, <a class="el" href="a00328_source.html#l00131">uip_ext_bitmap</a>, <a class="el" href="a00285_source.html#l01908">UIP_EXT_HDR_BITMAP_HBHO</a>, <a class="el" href="a00328_source.html#l00136">uip_ext_len</a>, <a class="el" href="a00285_source.html#l01236">UIP_HTONS</a>, <a class="el" href="a00324_source.html#l00279">uip_icmp6_echo_reply_input()</a>, <a class="el" href="a00324_source.html#l00080">uip_icmp6_echo_request_input()</a>, <a class="el" href="a00324_source.html#l00167">uip_icmp6_error_output()</a>, <a class="el" href="a00328_source.html#l00386">uip_icmp6chksum()</a>, <a class="el" href="a00326_source.html#l00105">UIP_ICMP_BUF</a>, <a class="el" href="a00326_source.html#l00104">UIP_IP_BUF</a>, <a class="el" href="a00285_source.html#l01024">uip_ipaddr_copy</a>, <a class="el" href="a00285_source.html#l02056">uip_is_addr_link_local</a>, <a class="el" href="a00285_source.html#l01946">uip_is_addr_loopback</a>, <a class="el" href="a00285_source.html#l02093">uip_is_addr_mcast</a>, <a class="el" href="a00285_source.html#l02121">uip_is_addr_mcast_routable</a>, <a class="el" href="a00285_source.html#l01960">uip_is_addr_unspecified</a>, <a class="el" href="a00328_source.html#l00184">uip_len</a>, <a class="el" href="a00289_source.html#l00283">UIP_LINK_MTU</a>, <a class="el" href="a00289_source.html#l00433">UIP_LISTENPORTS</a>, <a class="el" href="a00289_source.html#l00160">UIP_LLH_LEN</a>, <a class="el" href="a00289_source.html#l00462">UIP_MAXRTX</a>, <a class="el" href="a00289_source.html#l00471">UIP_MAXSYNRTX</a>, <a class="el" href="a00326_source.html#l00396">uip_nd6_na_input()</a>, <a class="el" href="a00326_source.html#l00147">uip_nd6_ns_input()</a>, <a class="el" href="a00326_source.html#l00768">uip_nd6_ra_input()</a>, <a class="el" href="a00328_source.html#l00129">uip_next_hdr</a>, <a class="el" href="a00285_source.html#l01884">UIP_PROTO_HBHO</a>, <a class="el" href="a00289_source.html#l00498">UIP_RECEIVE_WINDOW</a>, <a class="el" href="a00289_source.html#l00454">UIP_RTO</a>, <a class="el" href="a00285_source.html#l01429">UIP_STAT</a>, <a class="el" href="a00289_source.html#l00485">UIP_TCP_MSS</a>, <a class="el" href="a00520_source.html#l00310">uip_tcpchksum()</a>, <a class="el" href="a00289_source.html#l00509">UIP_TIME_WAIT_TIMEOUT</a>, <a class="el" href="a01866.html#ga210f227119fc972e6222c9cb452e15a9">uip_udp_conn</a>, <a class="el" href="a00289_source.html#l00365">UIP_UDP_CONNS</a>, and <a class="el" href="a01866.html#gaeb447241dcd4e7840ea4b0603fc2c330">uip_udpchksum()</a>.</p>

</div>
</div>
<a class="anchor" id="ga969ff8bccf86e1c4becc3c3fd23f93b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uip_tcpchksum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the TCP checksum of the packet in uip_buf and uip_appdata. </p>
<p>The TCP checksum is the Internet checksum of data contents of the TCP segment, and a pseudo-header as defined in RFC793.</p>
<dl class="section return"><dt>Returns</dt><dd>The TCP checksum of the TCP segment in uip_buf and pointed to by uip_appdata. </dd></dl>

<p>Definition at line <a class="el" href="a00520_source.html#l00310">310</a> of file <a class="el" href="a00520_source.html">uip_arch.c</a>.</p>

<p>Referenced by <a class="el" href="a00328_source.html#l00918">uip_process()</a>, and <a class="el" href="a00281_source.html#l00054">uip_split_output()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb447241dcd4e7840ea4b0603fc2c330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uip_udpchksum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the UDP checksum of the packet in uip_buf and uip_appdata. </p>
<p>The UDP checksum is the Internet checksum of data contents of the UDP segment, and a pseudo-header as defined in RFC768.</p>
<dl class="section return"><dt>Returns</dt><dd>The UDP checksum of the UDP segment in uip_buf and pointed to by uip_appdata. </dd></dl>

<p>Referenced by <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gad5848369ab5b02f2fb02d8390ccbaf79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> void* uip_appdata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the application data in the packet buffer. </p>
<p>This pointer points to the application data when the application is called. If the application wishes to send data, the application may use this space to write the data into before calling <a class="el" href="a01726.html#ga73635e084b87a4dd7535f579e680f268" title="Send data on the current connection.">uip_send()</a>. </p>

<p>Definition at line <a class="el" href="a00328_source.html#l00173">173</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

<p>Referenced by <a class="el" href="a00267_source.html#l00095">slipdev_send()</a>, <a class="el" href="a00304_source.html#l00364">uip_arp_out()</a>, <a class="el" href="a00297_source.html#l00403">uip_fw_forward()</a>, <a class="el" href="a00328_source.html#l00918">uip_process()</a>, <a class="el" href="a00281_source.html#l00054">uip_split_output()</a>, and <a class="el" href="a00520_source.html#l00310">uip_tcpchksum()</a>.</p>

</div>
</div>
<a class="anchor" id="ga76f4b1021e1a18d4d857ca8c121ec6e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01366.html#ace2c3395110fad22d5d766b6c2b324d1">CCIF</a> struct <a class="el" href="a00108.html">uip_conn</a>* <a class="el" href="a00108.html">uip_conn</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the current TCP connection. </p>
<p>The <a class="el" href="a00108.html" title="Representation of a uIP TCP connection.">uip_conn</a> pointer can be used to access the current TCP connection. </p>

<p>Definition at line <a class="el" href="a00328_source.html#l00196">196</a> of file <a class="el" href="a00328_source.html">uip6.c</a>.</p>

<p>Referenced by <a class="el" href="a00328_source.html#l00918">uip_process()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 24 2014 16:26:19 for Contiki-Inga 3.x by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
